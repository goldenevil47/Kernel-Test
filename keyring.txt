lib/digsig.c: * @keyring:	keyring to search key in
lib/digsig.c:int digsig_verify(struct key *keyring, const char *sig, int siglen,
lib/digsig.c:	if (keyring) {
lib/digsig.c:		/* search in specific keyring */
lib/digsig.c:		kref = keyring_search(make_key_ref(keyring, 1UL),
certs/Kconfig:config SYSTEM_TRUSTED_KEYRING
certs/Kconfig:	  Provide a system keyring to which trusted keys can be added.  Keys in
certs/Kconfig:	  the keyring are considered to be trusted.  Keys may be added at will
certs/Kconfig:	  keys already in the keyring.
certs/Kconfig:	  Keys in this keyring are used by module signature checking.
certs/Kconfig:	string "Additional X.509 keys for default system keyring"
certs/Kconfig:	depends on SYSTEM_TRUSTED_KEYRING
certs/Kconfig:	  system keyring. Any certificate used for module signing is implicitly
certs/Kconfig:	  NOTE: If you previously provided keys for the system keyring in the
certs/Makefile:obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o
certs/Makefile:ifeq ($(CONFIG_SYSTEM_TRUSTED_KEYRING),y)
certs/system_keyring.c:/* System trusted keyring for trusted public keys
certs/system_keyring.c:#include <keys/system_keyring.h>
certs/system_keyring.c:struct key *system_trusted_keyring;
certs/system_keyring.c:EXPORT_SYMBOL_GPL(system_trusted_keyring);
certs/system_keyring.c:static __init int system_trusted_keyring_init(void)
certs/system_keyring.c:	pr_notice("Initialise system trusted keyring\n");
certs/system_keyring.c:	system_trusted_keyring =
certs/system_keyring.c:		keyring_alloc(".system_keyring",
certs/system_keyring.c:	if (IS_ERR(system_trusted_keyring))
certs/system_keyring.c:		panic("Can't allocate system trusted keyring\n");
certs/system_keyring.c:	set_bit(KEY_FLAG_TRUSTED_ONLY, &system_trusted_keyring->flags);
certs/system_keyring.c: * Must be initialised before we try and load the keys into the keyring.
certs/system_keyring.c:device_initcall(system_trusted_keyring_init);
certs/system_keyring.c:		key = key_create_or_update(make_key_ref(system_trusted_keyring, 1),
certs/system_keyring.c:	ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);
arch/x86/Kconfig:	select SYSTEM_TRUSTED_KEYRING
arch/x86/kernel/kexec-bzimage64.c:#include <keys/system_keyring.h>
arch/x86/kernel/kexec-bzimage64.c:				      system_trusted_keyring,
arch/arm64/configs/siberia_defconfig:CONFIG_PERSISTENT_KEYRINGS=y
arch/arm64/configs/siberia_defconfig:# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
arch/arm64/configs/merge_hi6250_defconfig:# CONFIG_PERSISTENT_KEYRINGS is not set
arch/arm64/configs/merge_hi6250_defconfig:# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
security/integrity/Kconfig:	bool "Digital signature verification using multiple keyrings"
security/integrity/Kconfig:	  using multiple keyrings. It defines separate keyrings for each
security/integrity/Kconfig:	  Different keyrings improves search performance, but also allow
security/integrity/Kconfig:	  to "lock" certain keyring to prevent adding new keys.
security/integrity/Kconfig:	  This is useful for evm and module keyrings, when keys are
security/integrity/ima/Kconfig:config IMA_TRUSTED_KEYRING
security/integrity/ima/Kconfig:	bool "Require all keys on the .ima keyring be signed"
security/integrity/ima/Kconfig:	depends on IMA_APPRAISE && SYSTEM_TRUSTED_KEYRING
security/integrity/ima/Kconfig:	   keyring be signed by a key on the system trusted keyring.
security/integrity/ima/Kconfig:	bool "Load X509 certificate onto the '.ima' trusted keyring"
security/integrity/ima/Kconfig:	depends on IMA_TRUSTED_KEYRING
security/integrity/ima/Kconfig:	   loaded on the .ima trusted keyring. These public keys are
security/integrity/ima/Kconfig:	   .system keyring.  This option enables X509 certificate
security/integrity/ima/Kconfig:	   loading from the kernel onto the '.ima' trusted keyring.
security/integrity/ima/ima_init.c:	integrity_load_x509(INTEGRITY_KEYRING_IMA, CONFIG_IMA_X509_PATH);
security/integrity/ima/ima_init.c:	rc = ima_init_keyring(INTEGRITY_KEYRING_IMA);
security/integrity/ima/ima_appraise.c:		rc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,
security/integrity/ima/ima.h:#ifdef CONFIG_IMA_TRUSTED_KEYRING
security/integrity/ima/ima.h:static inline int ima_init_keyring(const unsigned int id)
security/integrity/ima/ima.h:	return integrity_init_keyring(id);
security/integrity/ima/ima.h:static inline int ima_init_keyring(const unsigned int id)
security/integrity/ima/ima.h:#endif /* CONFIG_IMA_TRUSTED_KEYRING */
security/integrity/digsig_asymmetric.c:static struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)
security/integrity/digsig_asymmetric.c:	if (keyring) {
security/integrity/digsig_asymmetric.c:		/* search in specific keyring */
security/integrity/digsig_asymmetric.c:		kref = keyring_search(make_key_ref(keyring, 1),
security/integrity/digsig_asymmetric.c:int asymmetric_verify(struct key *keyring, const char *sig,
security/integrity/digsig_asymmetric.c:	key = request_asymmetric_key(keyring, __be32_to_cpu(hdr->keyid));
security/integrity/evm/evm_main.c:		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
security/integrity/evm/evm_secfs.c: *	- Used to signal when key is on keyring
security/integrity/integrity.h:#define INTEGRITY_KEYRING_EVM		0
security/integrity/integrity.h:#define INTEGRITY_KEYRING_MODULE	1
security/integrity/integrity.h:#define INTEGRITY_KEYRING_IMA		2
security/integrity/integrity.h:#define INTEGRITY_KEYRING_MAX		3
security/integrity/integrity.h:int __init integrity_init_keyring(const unsigned int id);
security/integrity/integrity.h:static inline int integrity_init_keyring(const unsigned int id)
security/integrity/integrity.h:int asymmetric_verify(struct key *keyring, const char *sig,
security/integrity/integrity.h:static inline int asymmetric_verify(struct key *keyring, const char *sig,
security/integrity/digsig.c:static struct key *keyring[INTEGRITY_KEYRING_MAX];
security/integrity/digsig.c:static const char *keyring_name[INTEGRITY_KEYRING_MAX] = {
security/integrity/digsig.c:#ifndef CONFIG_IMA_TRUSTED_KEYRING
security/integrity/digsig.c:	if (id >= INTEGRITY_KEYRING_MAX)
security/integrity/digsig.c:	if (!keyring[id]) {
security/integrity/digsig.c:		keyring[id] =
security/integrity/digsig.c:			request_key(&key_type_keyring, keyring_name[id], NULL);
security/integrity/digsig.c:		if (IS_ERR(keyring[id])) {
security/integrity/digsig.c:			int err = PTR_ERR(keyring[id]);
security/integrity/digsig.c:			pr_err("no %s keyring: %d\n", keyring_name[id], err);
security/integrity/digsig.c:			keyring[id] = NULL;
security/integrity/digsig.c:		return digsig_verify(keyring[id], sig + 1, siglen - 1,
security/integrity/digsig.c:		return asymmetric_verify(keyring[id], sig, siglen,
security/integrity/digsig.c:int __init integrity_init_keyring(const unsigned int id)
security/integrity/digsig.c:	keyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),
security/integrity/digsig.c:	if (!IS_ERR(keyring[id]))
security/integrity/digsig.c:		set_bit(KEY_FLAG_TRUSTED_ONLY, &keyring[id]->flags);
security/integrity/digsig.c:		err = PTR_ERR(keyring[id]);
security/integrity/digsig.c:		pr_info("Can't allocate %s keyring (%d)\n",
security/integrity/digsig.c:			keyring_name[id], err);
security/integrity/digsig.c:		keyring[id] = NULL;
security/integrity/digsig.c:	if (!keyring[id])
security/integrity/digsig.c:	key = key_create_or_update(make_key_ref(keyring[id], 1),
security/keys/Kconfig:	  Furthermore, a special type of key is available that acts as keyring:
security/keys/Kconfig:	  to five standard keyrings: UID-specific, GID-specific, session,
security/keys/Kconfig:config PERSISTENT_KEYRINGS
security/keys/Kconfig:	bool "Enable register of persistent per-UID keyrings"
security/keys/Kconfig:	  This option provides a register of persistent per-UID keyrings,
security/keys/Kconfig:	  primarily aimed at Kerberos key storage.  The keyrings are persistent
security/keys/Kconfig:	  A particular keyring may be accessed by either the user whose keyring
security/keys/Kconfig:	  Keyrings are created and added into the register upon demand and get
security/keys/trusted.c: * adding it to the specified keyring.
security/keys/keyctl.c: * new key to the specified keyring or update a matching key in that keyring.
security/keys/keyctl.c: * The keyring must be writable so that we can attach the key to it.
security/keys/keyctl.c:	key_ref_t keyring_ref, key_ref;
security/keys/keyctl.c:			   (strncmp(type, "keyring", 7) == 0)) {
security/keys/keyctl.c:	/* find the target keyring (which must be writable) */
security/keys/keyctl.c:	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
security/keys/keyctl.c:	if (IS_ERR(keyring_ref)) {
security/keys/keyctl.c:		ret = PTR_ERR(keyring_ref);
security/keys/keyctl.c:	 * keyring */
security/keys/keyctl.c:	key_ref = key_create_or_update(keyring_ref, type, description,
security/keys/keyctl.c:	key_ref_put(keyring_ref);
security/keys/keyctl.c: * Search the process keyrings and keyring trees linked from those for a
security/keys/keyctl.c: * matching key.  Keyrings must have appropriate Search permission to be
security/keys/keyctl.c: * If a key is found, it will be attached to the destination keyring if there's
security/keys/keyctl.c:	/* get the destination keyring if specified */
security/keys/keyctl.c: * Get the ID of the specified process keyring.
security/keys/keyctl.c: * The requested keyring must have search permission to be found.
security/keys/keyctl.c: * If successful, the ID of the requested keyring will be returned.
security/keys/keyctl.c:long keyctl_get_keyring_ID(key_serial_t id, int create)
security/keys/keyctl.c: * Join a (named) session keyring.
security/keys/keyctl.c: * Create and join an anonymous session keyring or join a named session
security/keys/keyctl.c: * keyring, creating it if necessary.  A named session keyring must have Search
security/keys/keyctl.c: * permission for it to be joined.  Session keyrings without this permit will
security/keys/keyctl.c: * keyrings whose name begin with a dot.
security/keys/keyctl.c: * If successful, the ID of the joined session keyring will be returned.
security/keys/keyctl.c:long keyctl_join_session_keyring(const char __user *_name)
security/keys/keyctl.c:	ret = join_session_keyring(name);
security/keys/keyctl.c: * Clear the specified keyring, creating an empty process keyring if one of the
security/keys/keyctl.c: * special keyring IDs is used.
security/keys/keyctl.c: * The keyring must grant the caller Write permission for this to work.  If
security/keys/keyctl.c:long keyctl_keyring_clear(key_serial_t ringid)
security/keys/keyctl.c:	key_ref_t keyring_ref;
security/keys/keyctl.c:	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
security/keys/keyctl.c:	if (IS_ERR(keyring_ref)) {
security/keys/keyctl.c:		ret = PTR_ERR(keyring_ref);
security/keys/keyctl.c:		/* Root is permitted to invalidate certain special keyrings */
security/keys/keyctl.c:			keyring_ref = lookup_user_key(ringid, 0, 0);
security/keys/keyctl.c:			if (IS_ERR(keyring_ref))
security/keys/keyctl.c:				     &key_ref_to_ptr(keyring_ref)->flags))
security/keys/keyctl.c:	ret = keyring_clear(key_ref_to_ptr(keyring_ref));
security/keys/keyctl.c:	key_ref_put(keyring_ref);
security/keys/keyctl.c: * Create a link from a keyring to a key if there's no matching key in the
security/keys/keyctl.c: * keyring, otherwise replace the link to the matching key with a link to the
security/keys/keyctl.c: * The key must grant the caller Link permission and the the keyring must grant
security/keys/keyctl.c: * the keyring's quota will be extended.
security/keys/keyctl.c:long keyctl_keyring_link(key_serial_t id, key_serial_t ringid)
security/keys/keyctl.c:	key_ref_t keyring_ref, key_ref;
security/keys/keyctl.c:	keyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);
security/keys/keyctl.c:	if (IS_ERR(keyring_ref)) {
security/keys/keyctl.c:		ret = PTR_ERR(keyring_ref);
security/keys/keyctl.c:	ret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));
security/keys/keyctl.c:	key_ref_put(keyring_ref);
security/keys/keyctl.c: * Unlink a key from a keyring.
security/keys/keyctl.c: * The keyring must grant the caller Write permission for this to work; the key
security/keys/keyctl.c:long keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)
security/keys/keyctl.c:	key_ref_t keyring_ref, key_ref;
security/keys/keyctl.c:	keyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);
security/keys/keyctl.c:	if (IS_ERR(keyring_ref)) {
security/keys/keyctl.c:		ret = PTR_ERR(keyring_ref);
security/keys/keyctl.c:	ret = key_unlink(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));
security/keys/keyctl.c:	key_ref_put(keyring_ref);
security/keys/keyctl.c: * Search the specified keyring and any keyrings it links to for a matching
security/keys/keyctl.c: * key.  Only keyrings that grant the caller Search permission will be searched
security/keys/keyctl.c: * (this includes the starting keyring).  Only keys with Search permission can
security/keys/keyctl.c: * If successful, the found key will be linked to the destination keyring if
security/keys/keyctl.c:long keyctl_keyring_search(key_serial_t ringid,
security/keys/keyctl.c:	key_ref_t keyring_ref, key_ref, dest_ref;
security/keys/keyctl.c:	/* get the keyring at which to begin the search */
security/keys/keyctl.c:	keyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);
security/keys/keyctl.c:	if (IS_ERR(keyring_ref)) {
security/keys/keyctl.c:		ret = PTR_ERR(keyring_ref);
security/keys/keyctl.c:	/* get the destination keyring if specified */
security/keys/keyctl.c:	key_ref = keyring_search(keyring_ref, ktype, description);
security/keys/keyctl.c:	/* link the resulting key to the destination keyring if we can */
security/keys/keyctl.c:	key_ref_put(keyring_ref);
security/keys/keyctl.c: * caller Search permission when searched for from the process keyrings.
security/keys/keyctl.c:	/* we can't; see if it's searchable from this process's keyrings
security/keys/keyctl.c: * Get the destination keyring for instantiation and check that the caller has
security/keys/keyctl.c:static long get_instantiation_keyring(key_serial_t ringid,
security/keys/keyctl.c:				      struct key **_dest_keyring)
security/keys/keyctl.c:	*_dest_keyring = NULL;
security/keys/keyctl.c:	/* if a specific keyring is nominated by ID, then use that */
security/keys/keyctl.c:		*_dest_keyring = key_ref_to_ptr(dkref);
security/keys/keyctl.c:	/* otherwise specify the destination keyring recorded in the
security/keys/keyctl.c:	 * authorisation key (any KEY_SPEC_*_KEYRING) */
security/keys/keyctl.c:	if (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {
security/keys/keyctl.c:		*_dest_keyring = key_get(rka->dest_keyring);
security/keys/keyctl.c: * destination keyring if one is given.
security/keys/keyctl.c:	struct key *instkey, *dest_keyring;
security/keys/keyctl.c:	/* find the destination keyring amongst those belonging to the
security/keys/keyctl.c:	ret = get_instantiation_keyring(ringid, rka, &dest_keyring);
security/keys/keyctl.c:	/* instantiate the key and link it into a keyring */
security/keys/keyctl.c:				       dest_keyring, instkey);
security/keys/keyctl.c:	key_put(dest_keyring);
security/keys/keyctl.c: * destination keyring if one is given.
security/keys/keyctl.c: * the destination keyring if one is given.
security/keys/keyctl.c: * the key into the destination keyring if one is given.
security/keys/keyctl.c: * code and link the key into the destination keyring if one is given.
security/keys/keyctl.c:	struct key *instkey, *dest_keyring;
security/keys/keyctl.c:	/* find the destination keyring if present (which must also be
security/keys/keyctl.c:	ret = get_instantiation_keyring(ringid, rka, &dest_keyring);
security/keys/keyctl.c:	/* instantiate the key and link it into a keyring */
security/keys/keyctl.c:				  dest_keyring, instkey);
security/keys/keyctl.c:	key_put(dest_keyring);
security/keys/keyctl.c: * Read or set the default keyring in which request_key() will cache keys and
security/keys/keyctl.c: * If a thread or process keyring is specified then it will be created if it
security/keys/keyctl.c:long keyctl_set_reqkey_keyring(int reqkey_defl)
security/keys/keyctl.c:	old_setting = current_cred_xxx(jit_keyring);
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_THREAD_KEYRING:
security/keys/keyctl.c:		ret = install_thread_keyring_to_cred(new);
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_PROCESS_KEYRING:
security/keys/keyctl.c:		ret = install_process_keyring_to_cred(new);
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_SESSION_KEYRING:
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_USER_KEYRING:
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_REQUESTOR_KEYRING:
security/keys/keyctl.c:	case KEY_REQKEY_DEFL_GROUP_KEYRING:
security/keys/keyctl.c:	new->jit_keyring = reqkey_defl;
security/keys/keyctl.c: * The caller must have the instantiation key in their process keyrings with a
security/keys/keyctl.c:	 * - the authorisation key must be in the current task's keyrings
security/keys/keyctl.c: * Attempt to install the calling process's session keyring on the process's
security/keys/keyctl.c: * The keyring must exist and must grant the caller LINK permission, and the
security/keys/keyctl.c: * The keyring will be emplaced on the parent when it next resumes userspace.
security/keys/keyctl.c:	key_ref_t keyring_r;
security/keys/keyctl.c:	keyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);
security/keys/keyctl.c:	if (IS_ERR(keyring_r))
security/keys/keyctl.c:		return PTR_ERR(keyring_r);
security/keys/keyctl.c:		goto error_keyring;
security/keys/keyctl.c:	cred->session_keyring = key_ref_to_ptr(keyring_r);
security/keys/keyctl.c:	keyring_r = NULL;
security/keys/keyctl.c:	init_task_work(newwork, key_change_session_keyring);
security/keys/keyctl.c:	/* the parent and the child must have different session keyrings or
security/keys/keyctl.c:	    mycred->session_keyring == pcred->session_keyring) {
security/keys/keyctl.c:	/* the keyrings must have the same UID */
security/keys/keyctl.c:	if ((pcred->session_keyring &&
security/keys/keyctl.c:	     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||
security/keys/keyctl.c:	    !uid_eq(mycred->session_keyring->uid, mycred->euid))
security/keys/keyctl.c:	/* cancel an already pending keyring replacement */
security/keys/keyctl.c:	oldwork = task_work_cancel(parent, key_change_session_keyring);
security/keys/keyctl.c:	/* the replacement session keyring is applied just prior to userspace
security/keys/keyctl.c:error_keyring:
security/keys/keyctl.c:	key_ref_put(keyring_r);
security/keys/keyctl.c:	case KEYCTL_GET_KEYRING_ID:
security/keys/keyctl.c:		return keyctl_get_keyring_ID((key_serial_t) arg2,
security/keys/keyctl.c:	case KEYCTL_JOIN_SESSION_KEYRING:
security/keys/keyctl.c:		return keyctl_join_session_keyring((const char __user *) arg2);
security/keys/keyctl.c:		return keyctl_keyring_clear((key_serial_t) arg2);
security/keys/keyctl.c:		return keyctl_keyring_link((key_serial_t) arg2,
security/keys/keyctl.c:		return keyctl_keyring_unlink((key_serial_t) arg2,
security/keys/keyctl.c:		return keyctl_keyring_search((key_serial_t) arg2,
security/keys/keyctl.c:	case KEYCTL_SET_REQKEY_KEYRING:
security/keys/keyctl.c:		return keyctl_set_reqkey_keyring(arg2);
security/keys/Makefile:	keyring.o \
security/keys/Makefile:obj-$(CONFIG_PERSISTENT_KEYRINGS) += persistent.o
security/keys/process_keys.c:/* Manage a process's keyrings
security/keys/process_keys.c:/* Session keyring create vs join semaphore */
security/keys/process_keys.c:/* User keyring creation semaphore */
security/keys/process_keys.c:static DEFINE_MUTEX(key_user_keyring_mutex);
security/keys/process_keys.c: * Install the user and user session keyrings for the current process's UID.
security/keys/process_keys.c:int install_user_keyrings(void)
security/keys/process_keys.c:	struct key *uid_keyring, *session_keyring;
security/keys/process_keys.c:	key_perm_t user_keyring_perm;
security/keys/process_keys.c:	user_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;
security/keys/process_keys.c:	if (user->uid_keyring && user->session_keyring) {
security/keys/process_keys.c:	mutex_lock(&key_user_keyring_mutex);
security/keys/process_keys.c:	if (!user->uid_keyring) {
security/keys/process_keys.c:		/* get the UID-specific keyring
security/keys/process_keys.c:		uid_keyring = find_keyring_by_name(buf, true);
security/keys/process_keys.c:		if (IS_ERR(uid_keyring)) {
security/keys/process_keys.c:			uid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,
security/keys/process_keys.c:						    cred, user_keyring_perm,
security/keys/process_keys.c:						    KEY_ALLOC_UID_KEYRING |
security/keys/process_keys.c:			if (IS_ERR(uid_keyring)) {
security/keys/process_keys.c:				ret = PTR_ERR(uid_keyring);
security/keys/process_keys.c:		/* get a default session keyring (which might also exist
security/keys/process_keys.c:		session_keyring = find_keyring_by_name(buf, true);
security/keys/process_keys.c:		if (IS_ERR(session_keyring)) {
security/keys/process_keys.c:			session_keyring =
security/keys/process_keys.c:				keyring_alloc(buf, user->uid, INVALID_GID,
security/keys/process_keys.c:					      cred, user_keyring_perm,
security/keys/process_keys.c:					      KEY_ALLOC_UID_KEYRING |
security/keys/process_keys.c:			if (IS_ERR(session_keyring)) {
security/keys/process_keys.c:				ret = PTR_ERR(session_keyring);
security/keys/process_keys.c:			/* we install a link from the user session keyring to
security/keys/process_keys.c:			 * the user keyring */
security/keys/process_keys.c:			ret = key_link(session_keyring, uid_keyring);
security/keys/process_keys.c:		/* install the keyrings */
security/keys/process_keys.c:		user->uid_keyring = uid_keyring;
security/keys/process_keys.c:		user->session_keyring = session_keyring;
security/keys/process_keys.c:	mutex_unlock(&key_user_keyring_mutex);
security/keys/process_keys.c:	key_put(session_keyring);
security/keys/process_keys.c:	key_put(uid_keyring);
security/keys/process_keys.c:	mutex_unlock(&key_user_keyring_mutex);
security/keys/process_keys.c: * Install a thread keyring to the given credentials struct if it didn't have
security/keys/process_keys.c: * Return: 0 if a thread keyring is now present; -errno on failure.
security/keys/process_keys.c:int install_thread_keyring_to_cred(struct cred *new)
security/keys/process_keys.c:	struct key *keyring;
security/keys/process_keys.c:	if (new->thread_keyring)
security/keys/process_keys.c:	keyring = keyring_alloc("_tid", new->uid, new->gid, new,
security/keys/process_keys.c:	if (IS_ERR(keyring))
security/keys/process_keys.c:		return PTR_ERR(keyring);
security/keys/process_keys.c:	new->thread_keyring = keyring;
security/keys/process_keys.c: * Install a thread keyring to the current task if it didn't have one already.
security/keys/process_keys.c: * Return: 0 if a thread keyring is now present; -errno on failure.
security/keys/process_keys.c:static int install_thread_keyring(void)
security/keys/process_keys.c:	ret = install_thread_keyring_to_cred(new);
security/keys/process_keys.c: * Install a process keyring to the given credentials struct if it didn't have
security/keys/process_keys.c: * Return: 0 if a process keyring is now present; -errno on failure.
security/keys/process_keys.c:int install_process_keyring_to_cred(struct cred *new)
security/keys/process_keys.c:	struct key *keyring;
security/keys/process_keys.c:	if (new->process_keyring)
security/keys/process_keys.c:	keyring = keyring_alloc("_pid", new->uid, new->gid, new,
security/keys/process_keys.c:	if (IS_ERR(keyring))
security/keys/process_keys.c:		return PTR_ERR(keyring);
security/keys/process_keys.c:	new->process_keyring = keyring;
security/keys/process_keys.c: * Install a process keyring to the current task if it didn't have one already.
security/keys/process_keys.c: * Return: 0 if a process keyring is now present; -errno on failure.
security/keys/process_keys.c:static int install_process_keyring(void)
security/keys/process_keys.c:	ret = install_process_keyring_to_cred(new);
security/keys/process_keys.c: * Install the given keyring as the session keyring of the given credentials
security/keys/process_keys.c: * struct, replacing the existing one if any.  If the given keyring is NULL,
security/keys/process_keys.c: * then install a new anonymous session keyring.
security/keys/process_keys.c:int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)
security/keys/process_keys.c:	/* create an empty session keyring */
security/keys/process_keys.c:	if (!keyring) {
security/keys/process_keys.c:		if (cred->session_keyring)
security/keys/process_keys.c:		keyring = keyring_alloc("_ses", cred->uid, cred->gid, cred,
security/keys/process_keys.c:		if (IS_ERR(keyring))
security/keys/process_keys.c:			return PTR_ERR(keyring);
security/keys/process_keys.c:		__key_get(keyring);
security/keys/process_keys.c:	/* install the keyring */
security/keys/process_keys.c:	old = cred->session_keyring;
security/keys/process_keys.c:	rcu_assign_pointer(cred->session_keyring, keyring);
security/keys/process_keys.c: * Install the given keyring as the session keyring of the current task,
security/keys/process_keys.c: * replacing the existing one if any.  If the given keyring is NULL, then
security/keys/process_keys.c: * install a new anonymous session keyring.
security/keys/process_keys.c:static int install_session_keyring(struct key *keyring)
security/keys/process_keys.c:	ret = install_session_keyring_to_cred(new, keyring);
security/keys/process_keys.c:	/* update the ownership of the thread keyring */
security/keys/process_keys.c:	if (tsk->cred->thread_keyring) {
security/keys/process_keys.c:		down_write(&tsk->cred->thread_keyring->sem);
security/keys/process_keys.c:		tsk->cred->thread_keyring->uid = tsk->cred->fsuid;
security/keys/process_keys.c:		up_write(&tsk->cred->thread_keyring->sem);
security/keys/process_keys.c:	/* update the ownership of the thread keyring */
security/keys/process_keys.c:	if (tsk->cred->thread_keyring) {
security/keys/process_keys.c:		down_write(&tsk->cred->thread_keyring->sem);
security/keys/process_keys.c:		tsk->cred->thread_keyring->gid = tsk->cred->fsgid;
security/keys/process_keys.c:		up_write(&tsk->cred->thread_keyring->sem);
security/keys/process_keys.c: * Search the process keyrings attached to the supplied cred for the first
security/keys/process_keys.c: * This can only search keyrings that grant Search permission to the supplied
security/keys/process_keys.c: * credentials.  Keyrings linked to searched keyrings will also be searched if
security/keys/process_keys.c:key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)
security/keys/process_keys.c:	/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were
security/keys/process_keys.c:	 * none of the keyrings were searchable
security/keys/process_keys.c:	/* search the thread keyring first */
security/keys/process_keys.c:	if (ctx->cred->thread_keyring) {
security/keys/process_keys.c:		key_ref = keyring_search_aux(
security/keys/process_keys.c:			make_key_ref(ctx->cred->thread_keyring, 1), ctx);
security/keys/process_keys.c:	/* search the process keyring second */
security/keys/process_keys.c:	if (ctx->cred->process_keyring) {
security/keys/process_keys.c:		key_ref = keyring_search_aux(
security/keys/process_keys.c:			make_key_ref(ctx->cred->process_keyring, 1), ctx);
security/keys/process_keys.c:	/* search the session keyring */
security/keys/process_keys.c:	if (ctx->cred->session_keyring) {
security/keys/process_keys.c:		key_ref = keyring_search_aux(
security/keys/process_keys.c:			make_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),
security/keys/process_keys.c:	/* or search the user-session keyring */
security/keys/process_keys.c:	else if (ctx->cred->user->session_keyring) {
security/keys/process_keys.c:		key_ref = keyring_search_aux(
security/keys/process_keys.c:			make_key_ref(ctx->cred->user->session_keyring, 1),
security/keys/process_keys.c: * Search the process keyrings attached to the supplied cred for the first
security/keys/process_keys.c: * matching key in the manner of search_my_process_keyrings(), but also search
security/keys/process_keys.c: * Return same as search_my_process_keyrings().
security/keys/process_keys.c:key_ref_t search_process_keyrings(struct keyring_search_context *ctx)
security/keys/process_keys.c:	key_ref = search_my_process_keyrings(ctx);
security/keys/process_keys.c:	 * search the keyrings of the process mentioned there
security/keys/process_keys.c:			key_ref = search_process_keyrings(ctx);
security/keys/process_keys.c: * Flags can be passed to request that special keyrings be created if referred
security/keys/process_keys.c: * or -ENOMEM if a special keyring couldn't be created.
security/keys/process_keys.c:	struct keyring_search_context ctx = {
security/keys/process_keys.c:		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/process_keys.c:		.flags			= KEYRING_SEARCH_NO_STATE_CHECK,
security/keys/process_keys.c:	case KEY_SPEC_THREAD_KEYRING:
security/keys/process_keys.c:		if (!ctx.cred->thread_keyring) {
security/keys/process_keys.c:			ret = install_thread_keyring();
security/keys/process_keys.c:		key = ctx.cred->thread_keyring;
security/keys/process_keys.c:	case KEY_SPEC_PROCESS_KEYRING:
security/keys/process_keys.c:		if (!ctx.cred->process_keyring) {
security/keys/process_keys.c:			ret = install_process_keyring();
security/keys/process_keys.c:		key = ctx.cred->process_keyring;
security/keys/process_keys.c:	case KEY_SPEC_SESSION_KEYRING:
security/keys/process_keys.c:		if (!ctx.cred->session_keyring) {
security/keys/process_keys.c:			/* always install a session keyring upon access if one
security/keys/process_keys.c:			ret = install_user_keyrings();
security/keys/process_keys.c:				ret = join_session_keyring(NULL);
security/keys/process_keys.c:				ret = install_session_keyring(
security/keys/process_keys.c:					ctx.cred->user->session_keyring);
security/keys/process_keys.c:		} else if (ctx.cred->session_keyring ==
security/keys/process_keys.c:			   ctx.cred->user->session_keyring &&
security/keys/process_keys.c:			ret = join_session_keyring(NULL);
security/keys/process_keys.c:		key = rcu_dereference(ctx.cred->session_keyring);
security/keys/process_keys.c:	case KEY_SPEC_USER_KEYRING:
security/keys/process_keys.c:		if (!ctx.cred->user->uid_keyring) {
security/keys/process_keys.c:			ret = install_user_keyrings();
security/keys/process_keys.c:		key = ctx.cred->user->uid_keyring;
security/keys/process_keys.c:	case KEY_SPEC_USER_SESSION_KEYRING:
security/keys/process_keys.c:		if (!ctx.cred->user->session_keyring) {
security/keys/process_keys.c:			ret = install_user_keyrings();
security/keys/process_keys.c:		key = ctx.cred->user->session_keyring;
security/keys/process_keys.c:	case KEY_SPEC_GROUP_KEYRING:
security/keys/process_keys.c:		/* group keyrings are not yet supported */
security/keys/process_keys.c:	case KEY_SPEC_REQUESTOR_KEYRING:
security/keys/process_keys.c:			key = rka->dest_keyring;
security/keys/process_keys.c:		skey_ref = search_process_keyrings(&ctx);
security/keys/process_keys.c:	 * the permission checks as it is only concerned with the keyring */
security/keys/process_keys.c:	/* if we attempted to install a keyring, then it may have caused new
security/keys/process_keys.c: * Join the named keyring as the session keyring if possible else attempt to
security/keys/process_keys.c: * If the name is NULL, an empty anonymous keyring will be installed as the
security/keys/process_keys.c: * session keyring.
security/keys/process_keys.c: * Named session keyrings are joined with a semaphore held to prevent the
security/keys/process_keys.c: * keyrings from going away whilst the attempt is made to going them and also
security/keys/process_keys.c: * to prevent a race in creating compatible session keyrings.
security/keys/process_keys.c:long join_session_keyring(const char *name)
security/keys/process_keys.c:	struct key *keyring;
security/keys/process_keys.c:	/* if no name is provided, install an anonymous keyring */
security/keys/process_keys.c:		ret = install_session_keyring_to_cred(new, NULL);
security/keys/process_keys.c:		serial = new->session_keyring->serial;
security/keys/process_keys.c:	/* allow the user to join or create a named keyring */
security/keys/process_keys.c:	/* look for an existing keyring of this name */
security/keys/process_keys.c:	keyring = find_keyring_by_name(name, false);
security/keys/process_keys.c:	if (PTR_ERR(keyring) == -ENOKEY) {
security/keys/process_keys.c:		keyring = keyring_alloc(
security/keys/process_keys.c:		if (IS_ERR(keyring)) {
security/keys/process_keys.c:			ret = PTR_ERR(keyring);
security/keys/process_keys.c:	} else if (IS_ERR(keyring)) {
security/keys/process_keys.c:		ret = PTR_ERR(keyring);
security/keys/process_keys.c:	} else if (keyring == new->session_keyring) {
security/keys/process_keys.c:	/* we've got a keyring - now to install it */
security/keys/process_keys.c:	ret = install_session_keyring_to_cred(new, keyring);
security/keys/process_keys.c:	ret = keyring->serial;
security/keys/process_keys.c:	key_put(keyring);
security/keys/process_keys.c:	key_put(keyring);
security/keys/process_keys.c: * Replace a process's session keyring on behalf of one of its children when
security/keys/process_keys.c:void key_change_session_keyring(struct callback_head *twork)
security/keys/process_keys.c:	new->jit_keyring	= old->jit_keyring;
security/keys/process_keys.c:	new->thread_keyring	= key_get(old->thread_keyring);
security/keys/process_keys.c:	new->process_keyring	= key_get(old->process_keyring);
security/keys/process_keys.c: * Make sure that root's user and user-session keyrings exist.
security/keys/process_keys.c:static int __init init_root_keyring(void)
security/keys/process_keys.c:	return install_user_keyrings();
security/keys/process_keys.c:late_initcall(init_root_keyring);
security/keys/user_defined.c: * password pairs in the keyring that you do not want to be readable
security/keys/user_defined.c: * dispose of the links from a revoked keyring
security/keys/key.c:	if (flags & KEY_ALLOC_UID_KEYRING)
security/keys/key.c:		key->flags |= 1 << KEY_FLAG_UID_KEYRING;
security/keys/key.c: * Instantiate a key and link it into the target keyring atomically.  Must be
security/keys/key.c: * called with the target keyring's semaphore writelocked.  The target key's
security/keys/key.c:				      struct key *keyring,
security/keys/key.c:	key_check(keyring);
security/keys/key.c:			/* and link it into the destination keyring */
security/keys/key.c:			if (keyring)
security/keys/key.c: * key_instantiate_and_link - Instantiate a key and link it into the keyring.
security/keys/key.c: * @data: The data to use to instantiate the keyring.
security/keys/key.c: * @keyring: Keyring to create a link in on success (or NULL).
security/keys/key.c: * and, if successful, link it in to the destination keyring if one is
security/keys/key.c:			     struct key *keyring,
security/keys/key.c:	if (keyring) {
security/keys/key.c:		ret = __key_link_begin(keyring, &key->index_key, &edit);
security/keys/key.c:	ret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);
security/keys/key.c:	if (keyring)
security/keys/key.c:		__key_link_end(keyring, &key->index_key, edit);
security/keys/key.c: * key_reject_and_link - Negatively instantiate a key and link it into the keyring.
security/keys/key.c: * @keyring: Keyring to create a link in on success (or NULL).
security/keys/key.c: * destination keyring if one is supplied.  The key and any links to the key
security/keys/key.c:			struct key *keyring,
security/keys/key.c:	key_check(keyring);
security/keys/key.c:	if (keyring)
security/keys/key.c:		link_ret = __key_link_begin(keyring, &key->index_key, &edit);
security/keys/key.c:		/* and link it into the destination keyring */
security/keys/key.c:		if (keyring && link_ret == 0)
security/keys/key.c:	if (keyring && link_ret == 0)
security/keys/key.c:		__key_link_end(keyring, &key->index_key, edit);
security/keys/key.c: * @keyring_ref: A pointer to the destination keyring with possession flag.
security/keys/key.c: * Search the destination keyring for a key of the same description and if one
security/keys/key.c: * link to it from that keyring.
security/keys/key.c: * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the
security/keys/key.c: * caller isn't permitted to modify the keyring or the LSM did not permit
security/keys/key.c: * On success, the possession flag from the keyring ref will be tacked on to
security/keys/key.c:key_ref_t key_create_or_update(key_ref_t keyring_ref,
security/keys/key.c:	struct keyring_index_key index_key = {
security/keys/key.c:	struct key *keyring, *key = NULL;
security/keys/key.c:	keyring = key_ref_to_ptr(keyring_ref);
security/keys/key.c:	key_check(keyring);
security/keys/key.c:	if (keyring->type != &key_type_keyring)
security/keys/key.c:	if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
security/keys/key.c:	ret = __key_link_begin(keyring, &index_key, &edit);
security/keys/key.c:	 * to modify the keyring */
security/keys/key.c:	ret = key_permission(keyring_ref, KEY_NEED_WRITE);
security/keys/key.c:	 * key of the same type and description in the destination keyring and
security/keys/key.c:		key_ref = find_key_to_update(keyring_ref, &index_key);
security/keys/key.c:		if (index_key.type == &key_type_keyring ||
security/keys/key.c:	/* instantiate it and link it into the target keyring */
security/keys/key.c:	ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
security/keys/key.c:	key_ref = make_key_ref(key, is_key_possessed(keyring_ref));
security/keys/key.c:	__key_link_end(keyring, &index_key, edit);
security/keys/key.c:	__key_link_end(keyring, &index_key, edit);
security/keys/key.c:	list_add_tail(&key_type_keyring.link, &key_types_list);
security/keys/persistent.c:/* General persistent per-UID keyrings register
security/keys/persistent.c:unsigned persistent_keyring_expiry = 3 * 24 * 3600; /* Expire after 3 days of non-use */
security/keys/persistent.c: * Create the persistent keyring register for the current user namespace.
security/keys/persistent.c:	struct key *reg = keyring_alloc(".persistent_register",
security/keys/persistent.c:	ns->persistent_keyring_register = reg;
security/keys/persistent.c: * Create the persistent keyring for the specified user.
security/keys/persistent.c:				       struct keyring_index_key *index_key)
security/keys/persistent.c:	if (!ns->persistent_keyring_register) {
security/keys/persistent.c:		reg_ref = make_key_ref(ns->persistent_keyring_register, true);
security/keys/persistent.c:	persistent = keyring_alloc(index_key->description,
security/keys/persistent.c:				   ns->persistent_keyring_register);
security/keys/persistent.c: * Get the persistent keyring for a specific UID and link it to the nominated
security/keys/persistent.c: * keyring.
security/keys/persistent.c:	struct keyring_index_key index_key;
security/keys/persistent.c:	index_key.type = &key_type_keyring;
security/keys/persistent.c:	if (ns->persistent_keyring_register) {
security/keys/persistent.c:		reg_ref = make_key_ref(ns->persistent_keyring_register, true);
security/keys/persistent.c:		down_read(&ns->persistent_keyring_register_sem);
security/keys/persistent.c:		up_read(&ns->persistent_keyring_register_sem);
security/keys/persistent.c:	down_write(&ns->persistent_keyring_register_sem);
security/keys/persistent.c:	up_write(&ns->persistent_keyring_register_sem);
security/keys/persistent.c:			key_set_timeout(persistent, persistent_keyring_expiry);
security/keys/persistent.c: * Get the persistent keyring for a specific UID and link it to the nominated
security/keys/persistent.c: * keyring.
security/keys/persistent.c:	/* There must be a destination keyring */
security/keys/persistent.c:	if (key_ref_to_ptr(dest_ref)->type != &key_type_keyring) {
security/keys/compat.c: * link the key into the destination keyring if one is given.
security/keys/compat.c:	case KEYCTL_GET_KEYRING_ID:
security/keys/compat.c:		return keyctl_get_keyring_ID(arg2, arg3);
security/keys/compat.c:	case KEYCTL_JOIN_SESSION_KEYRING:
security/keys/compat.c:		return keyctl_join_session_keyring(compat_ptr(arg2));
security/keys/compat.c:		return keyctl_keyring_clear(arg2);
security/keys/compat.c:		return keyctl_keyring_link(arg2, arg3);
security/keys/compat.c:		return keyctl_keyring_unlink(arg2, arg3);
security/keys/compat.c:		return keyctl_keyring_search(arg2, compat_ptr(arg3),
security/keys/compat.c:	case KEYCTL_SET_REQKEY_KEYRING:
security/keys/compat.c:		return keyctl_set_reqkey_keyring(arg2);
security/keys/proc.c:	struct keyring_search_context ctx = {
security/keys/proc.c:		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/proc.c:		.flags			= KEYRING_SEARCH_NO_STATE_CHECK,
security/keys/proc.c:		skey_ref = search_my_process_keyrings(&ctx);
security/keys/gc.c:#include <keys/keyring-type.h>
security/keys/gc.c: * Reaper for links from keyrings to dead keys.
security/keys/gc.c:			if (key->type == &key_type_keyring)
security/keys/gc.c:				goto found_keyring;
security/keys/gc.c:		/* Make sure that all pending keyring payload destructions are
security/keys/gc.c:	/* We found a keyring and we need to check the payload for links to
security/keys/gc.c:found_keyring:
security/keys/gc.c:	keyring_gc(key, limit);
security/keys/big_key.c: * dispose of the links from a revoked keyring
security/keys/request_key_auth.c:	key_put(rka->dest_keyring);
security/keys/request_key_auth.c:				 size_t callout_len, struct key *dest_keyring)
security/keys/request_key_auth.c:	rka->dest_keyring = key_get(dest_keyring);
security/keys/request_key_auth.c:	key_put(rka->dest_keyring);
security/keys/request_key_auth.c: * Search the current process's keyrings for the authorisation key for
security/keys/request_key_auth.c:	struct keyring_search_context ctx = {
security/keys/request_key_auth.c:		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/request_key_auth.c:		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
security/keys/request_key_auth.c:	authkey_ref = search_process_keyrings(&ctx);
security/keys/internal.h: * (user_struct pins some keyrings which pin this struct).
security/keys/internal.h:#define KEYQUOTA_LINK_BYTES	4		/* a link in a keyring is worth 4 bytes */
security/keys/internal.h:extern int __key_link_begin(struct key *keyring,
security/keys/internal.h:			    const struct keyring_index_key *index_key,
security/keys/internal.h:extern int __key_link_check_live_key(struct key *keyring, struct key *key);
security/keys/internal.h:extern void __key_link_end(struct key *keyring,
security/keys/internal.h:			   const struct keyring_index_key *index_key,
security/keys/internal.h:extern key_ref_t find_key_to_update(key_ref_t keyring_ref,
security/keys/internal.h:				    const struct keyring_index_key *index_key);
security/keys/internal.h:extern struct key *keyring_search_instkey(struct key *keyring,
security/keys/internal.h:extern int iterate_over_keyring(const struct key *keyring,
security/keys/internal.h:struct keyring_search_context {
security/keys/internal.h:	struct keyring_index_key index_key;
security/keys/internal.h:#define KEYRING_SEARCH_NO_STATE_CHECK	0x0001	/* Skip state checks */
security/keys/internal.h:#define KEYRING_SEARCH_DO_STATE_CHECK	0x0002	/* Override NO_STATE_CHECK */
security/keys/internal.h:#define KEYRING_SEARCH_NO_UPDATE_TIME	0x0004	/* Don't update times */
security/keys/internal.h:#define KEYRING_SEARCH_NO_CHECK_PERM	0x0008	/* Don't check permissions */
security/keys/internal.h:#define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0010	/* Give an error on excessive depth */
security/keys/internal.h:#define KEYRING_SEARCH_SKIP_EXPIRED	0x0020	/* Ignore expired keys (intention to replace) */
security/keys/internal.h:extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,
security/keys/internal.h:				    struct keyring_search_context *ctx);
security/keys/internal.h:extern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);
security/keys/internal.h:extern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);
security/keys/internal.h:extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);
security/keys/internal.h:extern int install_user_keyrings(void);
security/keys/internal.h:extern int install_thread_keyring_to_cred(struct cred *);
security/keys/internal.h:extern int install_process_keyring_to_cred(struct cred *);
security/keys/internal.h:extern int install_session_keyring_to_cred(struct cred *, struct key *);
security/keys/internal.h:					struct key *dest_keyring,
security/keys/internal.h:extern long join_session_keyring(const char *name);
security/keys/internal.h:extern void key_change_session_keyring(struct callback_head *twork);
security/keys/internal.h:extern void keyring_gc(struct key *keyring, time_t limit);
security/keys/internal.h:	struct key		*dest_keyring;
security/keys/internal.h:					struct key *dest_keyring);
security/keys/internal.h:extern long keyctl_get_keyring_ID(key_serial_t, int);
security/keys/internal.h:extern long keyctl_join_session_keyring(const char __user *);
security/keys/internal.h:extern long keyctl_keyring_clear(key_serial_t);
security/keys/internal.h:extern long keyctl_keyring_link(key_serial_t, key_serial_t);
security/keys/internal.h:extern long keyctl_keyring_unlink(key_serial_t, key_serial_t);
security/keys/internal.h:extern long keyctl_keyring_search(key_serial_t, const char __user *,
security/keys/internal.h:extern long keyctl_set_reqkey_keyring(int);
security/keys/internal.h:#ifdef CONFIG_PERSISTENT_KEYRINGS
security/keys/internal.h:extern unsigned persistent_keyring_expiry;
security/keys/sysctl.c:#ifdef CONFIG_PERSISTENT_KEYRINGS
security/keys/sysctl.c:		.procname = "persistent_keyring_expiry",
security/keys/sysctl.c:		.data = &persistent_keyring_expiry,
security/keys/keyring.c:/* Keyring handling
security/keys/keyring.c:#include <keys/keyring-type.h>
security/keys/keyring.c:#define KEYRING_SEARCH_MAX_DEPTH 6
security/keys/keyring.c: * We keep all named keyrings in a hash to speed looking them up.
security/keys/keyring.c:#define KEYRING_NAME_HASH_SIZE	(1 << 5)
security/keys/keyring.c: * they're keyrings and clear otherwise.
security/keys/keyring.c:#define KEYRING_PTR_SUBTYPE	0x2UL
security/keys/keyring.c:static inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)
security/keys/keyring.c:	return (unsigned long)x & KEYRING_PTR_SUBTYPE;
security/keys/keyring.c:static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)
security/keys/keyring.c:	return (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);
security/keys/keyring.c:static inline void *keyring_key_to_ptr(struct key *key)
security/keys/keyring.c:	if (key->type == &key_type_keyring)
security/keys/keyring.c:		return (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);
security/keys/keyring.c:static struct list_head	keyring_name_hash[KEYRING_NAME_HASH_SIZE];
security/keys/keyring.c:static DEFINE_RWLOCK(keyring_name_lock);
security/keys/keyring.c:static inline unsigned keyring_hash(const char *desc)
security/keys/keyring.c:	return bucket & (KEYRING_NAME_HASH_SIZE - 1);
security/keys/keyring.c: * The keyring key type definition.  Keyrings are simply keys of this type and
security/keys/keyring.c:static int keyring_preparse(struct key_preparsed_payload *prep);
security/keys/keyring.c:static void keyring_free_preparse(struct key_preparsed_payload *prep);
security/keys/keyring.c:static int keyring_instantiate(struct key *keyring,
security/keys/keyring.c:static void keyring_revoke(struct key *keyring);
security/keys/keyring.c:static void keyring_destroy(struct key *keyring);
security/keys/keyring.c:static void keyring_describe(const struct key *keyring, struct seq_file *m);
security/keys/keyring.c:static long keyring_read(const struct key *keyring,
security/keys/keyring.c:struct key_type key_type_keyring = {
security/keys/keyring.c:	.name		= "keyring",
security/keys/keyring.c:	.preparse	= keyring_preparse,
security/keys/keyring.c:	.free_preparse	= keyring_free_preparse,
security/keys/keyring.c:	.instantiate	= keyring_instantiate,
security/keys/keyring.c:	.revoke		= keyring_revoke,
security/keys/keyring.c:	.destroy	= keyring_destroy,
security/keys/keyring.c:	.describe	= keyring_describe,
security/keys/keyring.c:	.read		= keyring_read,
security/keys/keyring.c:EXPORT_SYMBOL(key_type_keyring);
security/keys/keyring.c:static DECLARE_RWSEM(keyring_serialise_link_sem);
security/keys/keyring.c: * Publish the name of a keyring so that it can be found by name (if it has
security/keys/keyring.c:static void keyring_publish_name(struct key *keyring)
security/keys/keyring.c:	if (keyring->description) {
security/keys/keyring.c:		bucket = keyring_hash(keyring->description);
security/keys/keyring.c:		write_lock(&keyring_name_lock);
security/keys/keyring.c:		if (!keyring_name_hash[bucket].next)
security/keys/keyring.c:			INIT_LIST_HEAD(&keyring_name_hash[bucket]);
security/keys/keyring.c:		list_add_tail(&keyring->name_link,
security/keys/keyring.c:			      &keyring_name_hash[bucket]);
security/keys/keyring.c:		write_unlock(&keyring_name_lock);
security/keys/keyring.c: * Preparse a keyring payload
security/keys/keyring.c:static int keyring_preparse(struct key_preparsed_payload *prep)
security/keys/keyring.c:static void keyring_free_preparse(struct key_preparsed_payload *prep)
security/keys/keyring.c: * Initialise a keyring.
security/keys/keyring.c:static int keyring_instantiate(struct key *keyring,
security/keys/keyring.c:	assoc_array_init(&keyring->keys);
security/keys/keyring.c:	/* make the keyring available by name if it has one */
security/keys/keyring.c:	keyring_publish_name(keyring);
security/keys/keyring.c:static unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)
security/keys/keyring.c:	/* Squidge all the keyrings into a separate part of the tree to
security/keys/keyring.c:	 * zero for keyrings and non-zero otherwise.
security/keys/keyring.c:	if (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)
security/keys/keyring.c:	if (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)
security/keys/keyring.c:static unsigned long keyring_get_key_chunk(const void *data, int level)
security/keys/keyring.c:	const struct keyring_index_key *index_key = data;
security/keys/keyring.c:static unsigned long keyring_get_object_key_chunk(const void *object, int level)
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c:	return keyring_get_key_chunk(&key->index_key, level);
security/keys/keyring.c:static bool keyring_compare_object(const void *object, const void *data)
security/keys/keyring.c:	const struct keyring_index_key *index_key = data;
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c:static int keyring_diff_objects(const void *object, const void *data)
security/keys/keyring.c:	const struct key *key_a = keyring_ptr_to_key(object);
security/keys/keyring.c:	const struct keyring_index_key *a = &key_a->index_key;
security/keys/keyring.c:	const struct keyring_index_key *b = data;
security/keys/keyring.c: * Free an object after stripping the keyring flag off of the pointer.
security/keys/keyring.c:static void keyring_free_object(void *object)
security/keys/keyring.c:	key_put(keyring_ptr_to_key(object));
security/keys/keyring.c: * Operations for keyring management by the index-tree routines.
security/keys/keyring.c:static const struct assoc_array_ops keyring_assoc_array_ops = {
security/keys/keyring.c:	.get_key_chunk		= keyring_get_key_chunk,
security/keys/keyring.c:	.get_object_key_chunk	= keyring_get_object_key_chunk,
security/keys/keyring.c:	.compare_object		= keyring_compare_object,
security/keys/keyring.c:	.diff_objects		= keyring_diff_objects,
security/keys/keyring.c:	.free_object		= keyring_free_object,
security/keys/keyring.c: * Clean up a keyring when it is destroyed.  Unpublish its name if it had one
security/keys/keyring.c: * The garbage collector detects the final key_put(), removes the keyring from
security/keys/keyring.c:static void keyring_destroy(struct key *keyring)
security/keys/keyring.c:	if (keyring->description) {
security/keys/keyring.c:		write_lock(&keyring_name_lock);
security/keys/keyring.c:		if (keyring->name_link.next != NULL &&
security/keys/keyring.c:		    !list_empty(&keyring->name_link))
security/keys/keyring.c:			list_del(&keyring->name_link);
security/keys/keyring.c:		write_unlock(&keyring_name_lock);
security/keys/keyring.c:	assoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);
security/keys/keyring.c: * Describe a keyring for /proc.
security/keys/keyring.c:static void keyring_describe(const struct key *keyring, struct seq_file *m)
security/keys/keyring.c:	if (keyring->description)
security/keys/keyring.c:		seq_puts(m, keyring->description);
security/keys/keyring.c:	if (key_is_positive(keyring)) {
security/keys/keyring.c:		if (keyring->keys.nr_leaves_on_tree != 0)
security/keys/keyring.c:			seq_printf(m, ": %lu", keyring->keys.nr_leaves_on_tree);
security/keys/keyring.c:struct keyring_read_iterator_context {
security/keys/keyring.c:static int keyring_read_iterator(const void *object, void *data)
security/keys/keyring.c:	struct keyring_read_iterator_context *ctx = data;
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c: * Read a list of key IDs from the keyring's contents in binary form
security/keys/keyring.c: * The keyring's semaphore is read-locked by the caller.  This prevents someone
security/keys/keyring.c:static long keyring_read(const struct key *keyring,
security/keys/keyring.c:	struct keyring_read_iterator_context ctx;
security/keys/keyring.c:	kenter("{%d},,%zu", key_serial(keyring), buflen);
security/keys/keyring.c:		ret = assoc_array_iterate(&keyring->keys,
security/keys/keyring.c:					  keyring_read_iterator, &ctx);
security/keys/keyring.c:	ret = keyring->keys.nr_leaves_on_tree * sizeof(key_serial_t);
security/keys/keyring.c: * Allocate a keyring and link into the destination keyring.
security/keys/keyring.c:struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
security/keys/keyring.c:	struct key *keyring;
security/keys/keyring.c:	keyring = key_alloc(&key_type_keyring, description,
security/keys/keyring.c:	if (!IS_ERR(keyring)) {
security/keys/keyring.c:		ret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);
security/keys/keyring.c:			key_put(keyring);
security/keys/keyring.c:			keyring = ERR_PTR(ret);
security/keys/keyring.c:	return keyring;
security/keys/keyring.c:EXPORT_SYMBOL(keyring_alloc);
security/keys/keyring.c:static int keyring_search_iterator(const void *object, void *iterator_data)
security/keys/keyring.c:	struct keyring_search_context *ctx = iterator_data;
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c:	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
security/keys/keyring.c:			if (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))
security/keys/keyring.c:	if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
security/keys/keyring.c:	if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {
security/keys/keyring.c: * Search inside a keyring for a key.  We can search by walking to it
security/keys/keyring.c:static int search_keyring(struct key *keyring, struct keyring_search_context *ctx)
security/keys/keyring.c:	if (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {
security/keys/keyring.c:		object = assoc_array_find(&keyring->keys,
security/keys/keyring.c:					  &keyring_assoc_array_ops,
security/keys/keyring.c:	return assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);
security/keys/keyring.c: * Search a tree of keyrings that point to other keyrings up to the maximum
security/keys/keyring.c:static bool search_nested_keyrings(struct key *keyring,
security/keys/keyring.c:				   struct keyring_search_context *ctx)
security/keys/keyring.c:		struct key *keyring;
security/keys/keyring.c:	} stack[KEYRING_SEARCH_MAX_DEPTH];
security/keys/keyring.c:	       keyring->serial,
security/keys/keyring.c:#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)
security/keys/keyring.c:	/* Check to see if this top-level keyring is what we are looking for
security/keys/keyring.c:	if (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||
security/keys/keyring.c:	    keyring_compare_object(keyring, &ctx->index_key)) {
security/keys/keyring.c:		switch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {
security/keys/keyring.c:	/* Start processing a new keyring */
security/keys/keyring.c:descend_to_keyring:
security/keys/keyring.c:	kdebug("descend to %d", keyring->serial);
security/keys/keyring.c:	if (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |
security/keys/keyring.c:		goto not_this_keyring;
security/keys/keyring.c:	/* Search through the keys in this keyring before its searching its
security/keys/keyring.c:	if (search_keyring(keyring, ctx))
security/keys/keyring.c:	/* Then manually iterate through the keyrings nested in this one.
security/keys/keyring.c:	 * hash function has been set up, keyrings cluster on the leftmost
security/keys/keyring.c:	 * Non-keyrings avoid the leftmost branch of the root entirely (root
security/keys/keyring.c:	ptr = ACCESS_ONCE(keyring->keys.root);
security/keys/keyring.c:		goto not_this_keyring;
security/keys/keyring.c:		/* If the root is a shortcut, either the keyring only contains
security/keys/keyring.c:		 * keyring pointers (everything clusters behind root slot 0) or
security/keys/keyring.c:		 * doesn't contain any keyring pointers.
security/keys/keyring.c:			goto not_this_keyring;
security/keys/keyring.c:	/* Descend to a more distal node in this keyring's content tree and go
security/keys/keyring.c:		if (!keyring_ptr_is_keyring(ptr))
security/keys/keyring.c:		key = keyring_ptr_to_key(ptr);
security/keys/keyring.c:		if (sp >= KEYRING_SEARCH_MAX_DEPTH) {
security/keys/keyring.c:			if (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {
security/keys/keyring.c:			goto not_this_keyring;
security/keys/keyring.c:		/* Search a nested keyring */
security/keys/keyring.c:		if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&
security/keys/keyring.c:		stack[sp].keyring = keyring;
security/keys/keyring.c:		/* begin again with the new keyring */
security/keys/keyring.c:		keyring = key;
security/keys/keyring.c:		goto descend_to_keyring;
security/keys/keyring.c:		goto not_this_keyring;
security/keys/keyring.c:	 * so there can't be any more keyrings for us to find.
security/keys/keyring.c:	/* The keyring we're looking at was disqualified or didn't contain a
security/keys/keyring.c:not_this_keyring:
security/keys/keyring.c:	kdebug("not_this_keyring %d", sp);
security/keys/keyring.c:	/* Resume the processing of a keyring higher up in the tree */
security/keys/keyring.c:	keyring = stack[sp].keyring;
security/keys/keyring.c:	kdebug("ascend to %d [%d]", keyring->serial, slot);
security/keys/keyring.c:	if (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {
security/keys/keyring.c:		keyring->last_used_at = ctx->now.tv_sec;
security/keys/keyring.c:			stack[--sp].keyring->last_used_at = ctx->now.tv_sec;
security/keys/keyring.c: * keyring_search_aux - Search a keyring tree for a key matching some criteria
security/keys/keyring.c: * @keyring_ref: A pointer to the keyring with possession indicator.
security/keys/keyring.c: * @ctx: The keyring search context.
security/keys/keyring.c: * Search the supplied keyring tree for a key that matches the criteria given.
security/keys/keyring.c: * The root keyring and any linked keyrings must grant Search permission to the
security/keys/keyring.c: * to the caller. The possession flag on the root keyring pointer controls use
security/keys/keyring.c: * addition, the LSM gets to forbid keyring searches and key matches.
security/keys/keyring.c: * limit (KEYRING_SEARCH_MAX_DEPTH).
security/keys/keyring.c: * RCU can be used to prevent the keyring key lists from disappearing without
security/keys/keyring.c: * specified keyring wasn't a keyring.
security/keys/keyring.c: * @keyring_ref is propagated to the returned key reference.
security/keys/keyring.c:key_ref_t keyring_search_aux(key_ref_t keyring_ref,
security/keys/keyring.c:			     struct keyring_search_context *ctx)
security/keys/keyring.c:	struct key *keyring;
security/keys/keyring.c:	ctx->iterator = keyring_search_iterator;
security/keys/keyring.c:	ctx->possessed = is_key_possessed(keyring_ref);
security/keys/keyring.c:	keyring = key_ref_to_ptr(keyring_ref);
security/keys/keyring.c:	key_check(keyring);
security/keys/keyring.c:	if (keyring->type != &key_type_keyring)
security/keys/keyring.c:	if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {
security/keys/keyring.c:		err = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);
security/keys/keyring.c:	if (search_nested_keyrings(keyring, ctx))
security/keys/keyring.c: * keyring_search - Search the supplied keyring tree for a matching key
security/keys/keyring.c: * @keyring: The root of the keyring tree to be searched.
security/keys/keyring.c: * @type: The type of keyring we want to find.
security/keys/keyring.c: * @description: The name of the keyring we want to find.
security/keys/keyring.c: * As keyring_search_aux() above, but using the current task's credentials and
security/keys/keyring.c:key_ref_t keyring_search(key_ref_t keyring,
security/keys/keyring.c:	struct keyring_search_context ctx = {
security/keys/keyring.c:		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/keyring.c:		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
security/keys/keyring.c:	key = keyring_search_aux(keyring, &ctx);
security/keys/keyring.c:EXPORT_SYMBOL(keyring_search);
security/keys/keyring.c: * Search the given keyring for a key that might be updated.
security/keys/keyring.c: * The caller must guarantee that the keyring is a keyring and that the
security/keys/keyring.c: * permission is granted to modify the keyring as no check is made here.  The
security/keys/keyring.c: * caller must also hold a lock on the keyring semaphore.
security/keys/keyring.c: * If successful, the possession indicator is propagated from the keyring ref
security/keys/keyring.c:key_ref_t find_key_to_update(key_ref_t keyring_ref,
security/keys/keyring.c:			     const struct keyring_index_key *index_key)
security/keys/keyring.c:	struct key *keyring, *key;
security/keys/keyring.c:	keyring = key_ref_to_ptr(keyring_ref);
security/keys/keyring.c:	       keyring->serial, index_key->type->name, index_key->description);
security/keys/keyring.c:	object = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,
security/keys/keyring.c:	key = keyring_ptr_to_key(object);
security/keys/keyring.c:	return make_key_ref(key, is_key_possessed(keyring_ref));
security/keys/keyring.c: * Find a keyring with the specified name.
security/keys/keyring.c: * Only keyrings that have nonzero refcount, are not revoked, and are owned by a
security/keys/keyring.c: * user in the current user namespace are considered.  If @uid_keyring is %true,
security/keys/keyring.c: * the keyring additionally must have been allocated as a user or user session
security/keys/keyring.c: * keyring; otherwise, it must grant Search permission directly to the caller.
security/keys/keyring.c: * Returns a pointer to the keyring with the keyring's refcount having being
security/keys/keyring.c:struct key *find_keyring_by_name(const char *name, bool uid_keyring)
security/keys/keyring.c:	struct key *keyring;
security/keys/keyring.c:	bucket = keyring_hash(name);
security/keys/keyring.c:	read_lock(&keyring_name_lock);
security/keys/keyring.c:	if (keyring_name_hash[bucket].next) {
security/keys/keyring.c:		/* search this hash bucket for a keyring with a matching name
security/keys/keyring.c:		list_for_each_entry(keyring,
security/keys/keyring.c:				    &keyring_name_hash[bucket],
security/keys/keyring.c:			if (!kuid_has_mapping(current_user_ns(), keyring->user->uid))
security/keys/keyring.c:			if (test_bit(KEY_FLAG_REVOKED, &keyring->flags))
security/keys/keyring.c:			if (strcmp(keyring->description, name) != 0)
security/keys/keyring.c:			if (uid_keyring) {
security/keys/keyring.c:				if (!test_bit(KEY_FLAG_UID_KEYRING,
security/keys/keyring.c:					      &keyring->flags))
security/keys/keyring.c:				if (key_permission(make_key_ref(keyring, 0),
security/keys/keyring.c:			 * key_cleanup() if the keyring is currently 'dead'
security/keys/keyring.c:			if (!atomic_inc_not_zero(&keyring->usage))
security/keys/keyring.c:			keyring->last_used_at = current_kernel_time().tv_sec;
security/keys/keyring.c:	keyring = ERR_PTR(-ENOKEY);
security/keys/keyring.c:	read_unlock(&keyring_name_lock);
security/keys/keyring.c:	return keyring;
security/keys/keyring.c:static int keyring_detect_cycle_iterator(const void *object,
security/keys/keyring.c:	struct keyring_search_context *ctx = iterator_data;
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c:	/* We might get a keyring with matching index-key that is nonetheless a
security/keys/keyring.c:	 * different keyring. */
security/keys/keyring.c:static int keyring_detect_cycle(struct key *A, struct key *B)
security/keys/keyring.c:	struct keyring_search_context ctx = {
security/keys/keyring.c:		.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/keyring.c:		.iterator		= keyring_detect_cycle_iterator,
security/keys/keyring.c:		.flags			= (KEYRING_SEARCH_NO_STATE_CHECK |
security/keys/keyring.c:					   KEYRING_SEARCH_NO_UPDATE_TIME |
security/keys/keyring.c:					   KEYRING_SEARCH_NO_CHECK_PERM |
security/keys/keyring.c:					   KEYRING_SEARCH_DETECT_TOO_DEEP),
security/keys/keyring.c:	search_nested_keyrings(B, &ctx);
security/keys/keyring.c: * Preallocate memory so that a key can be linked into to a keyring.
security/keys/keyring.c:int __key_link_begin(struct key *keyring,
security/keys/keyring.c:		     const struct keyring_index_key *index_key,
security/keys/keyring.c:	__acquires(&keyring->sem)
security/keys/keyring.c:	__acquires(&keyring_serialise_link_sem)
security/keys/keyring.c:	       keyring->serial, index_key->type->name, index_key->description);
security/keys/keyring.c:	if (keyring->type != &key_type_keyring)
security/keys/keyring.c:	down_write(&keyring->sem);
security/keys/keyring.c:	if (test_bit(KEY_FLAG_REVOKED, &keyring->flags))
security/keys/keyring.c:	 * when linking two keyring in opposite orders */
security/keys/keyring.c:	if (index_key->type == &key_type_keyring)
security/keys/keyring.c:		down_write(&keyring_serialise_link_sem);
security/keys/keyring.c:	 * keyring tree.
security/keys/keyring.c:	edit = assoc_array_insert(&keyring->keys,
security/keys/keyring.c:				  &keyring_assoc_array_ops,
security/keys/keyring.c:		ret = key_payload_reserve(keyring,
security/keys/keyring.c:					  keyring->datalen + KEYQUOTA_LINK_BYTES);
security/keys/keyring.c:	if (index_key->type == &key_type_keyring)
security/keys/keyring.c:		up_write(&keyring_serialise_link_sem);
security/keys/keyring.c:	up_write(&keyring->sem);
security/keys/keyring.c:int __key_link_check_live_key(struct key *keyring, struct key *key)
security/keys/keyring.c:	if (key->type == &key_type_keyring)
security/keys/keyring.c:		 * keyring to another */
security/keys/keyring.c:		return keyring_detect_cycle(keyring, key);
security/keys/keyring.c: * Link a key into to a keyring.
security/keys/keyring.c: * already extant link to matching key if there is one, so that each keyring
security/keys/keyring.c:	assoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));
security/keys/keyring.c: * Finish linking a key into to a keyring.
security/keys/keyring.c:void __key_link_end(struct key *keyring,
security/keys/keyring.c:		    const struct keyring_index_key *index_key,
security/keys/keyring.c:	__releases(&keyring->sem)
security/keys/keyring.c:	__releases(&keyring_serialise_link_sem)
security/keys/keyring.c:	kenter("%d,%s,", keyring->serial, index_key->type->name);
security/keys/keyring.c:	if (index_key->type == &key_type_keyring)
security/keys/keyring.c:		up_write(&keyring_serialise_link_sem);
security/keys/keyring.c:			key_payload_reserve(keyring,
security/keys/keyring.c:				keyring->datalen - KEYQUOTA_LINK_BYTES);
security/keys/keyring.c:	up_write(&keyring->sem);
security/keys/keyring.c: * key_link - Link a key to a keyring
security/keys/keyring.c: * @keyring: The keyring to make the link in.
security/keys/keyring.c: * Make a link in a keyring to a key, such that the keyring holds a reference
security/keys/keyring.c: * on that key and the key can potentially be found by searching that keyring.
security/keys/keyring.c: * This function will write-lock the keyring's semaphore and will consume some
security/keys/keyring.c: * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,
security/keys/keyring.c: * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is
security/keys/keyring.c: * be made (the keyring should have Write permission and the key Link
security/keys/keyring.c:int key_link(struct key *keyring, struct key *key)
security/keys/keyring.c:	kenter("{%d,%d}", keyring->serial, atomic_read(&keyring->usage));
security/keys/keyring.c:	key_check(keyring);
security/keys/keyring.c:	if (test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags) &&
security/keys/keyring.c:	ret = __key_link_begin(keyring, &key->index_key, &edit);
security/keys/keyring.c:		kdebug("begun {%d,%d}", keyring->serial, atomic_read(&keyring->usage));
security/keys/keyring.c:		ret = __key_link_check_live_key(keyring, key);
security/keys/keyring.c:		__key_link_end(keyring, &key->index_key, edit);
security/keys/keyring.c:	kleave(" = %d {%d,%d}", ret, keyring->serial, atomic_read(&keyring->usage));
security/keys/keyring.c: * key_unlink - Unlink the first link to a key from a keyring.
security/keys/keyring.c: * @keyring: The keyring to remove the link from.
security/keys/keyring.c: * Remove a link from a keyring to a key.
security/keys/keyring.c: * This function will write-lock the keyring's semaphore.
security/keys/keyring.c: * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if
security/keys/keyring.c: * the key isn't linked to by the keyring or -ENOMEM if there's insufficient
security/keys/keyring.c: * be removed (the keyring should have Write permission; no permissions are
security/keys/keyring.c:int key_unlink(struct key *keyring, struct key *key)
security/keys/keyring.c:	key_check(keyring);
security/keys/keyring.c:	if (keyring->type != &key_type_keyring)
security/keys/keyring.c:	down_write(&keyring->sem);
security/keys/keyring.c:	edit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,
security/keys/keyring.c:	key_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);
security/keys/keyring.c:	up_write(&keyring->sem);
security/keys/keyring.c: * keyring_clear - Clear a keyring
security/keys/keyring.c: * @keyring: The keyring to clear.
security/keys/keyring.c: * Clear the contents of the specified keyring.
security/keys/keyring.c: * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.
security/keys/keyring.c:int keyring_clear(struct key *keyring)
security/keys/keyring.c:	if (keyring->type != &key_type_keyring)
security/keys/keyring.c:	down_write(&keyring->sem);
security/keys/keyring.c:	edit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);
security/keys/keyring.c:		key_payload_reserve(keyring, 0);
security/keys/keyring.c:	up_write(&keyring->sem);
security/keys/keyring.c:EXPORT_SYMBOL(keyring_clear);
security/keys/keyring.c: * Dispose of the links from a revoked keyring.
security/keys/keyring.c:static void keyring_revoke(struct key *keyring)
security/keys/keyring.c:	edit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);
security/keys/keyring.c:		key_payload_reserve(keyring, 0);
security/keys/keyring.c:static bool keyring_gc_select_iterator(void *object, void *iterator_data)
security/keys/keyring.c:	struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c:static int keyring_gc_check_iterator(const void *object, void *iterator_data)
security/keys/keyring.c:	const struct key *key = keyring_ptr_to_key(object);
security/keys/keyring.c: * Garbage collect pointers from a keyring.
security/keys/keyring.c: * Not called with any locks held.  The keyring's key struct will not be
security/keys/keyring.c:void keyring_gc(struct key *keyring, time_t limit)
security/keys/keyring.c:	kenter("%x{%s}", keyring->serial, keyring->description ?: "");
security/keys/keyring.c:	if (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |
security/keys/keyring.c:	/* scan the keyring looking for dead keys */
security/keys/keyring.c:	result = assoc_array_iterate(&keyring->keys,
security/keys/keyring.c:				     keyring_gc_check_iterator, &limit);
security/keys/keyring.c:	down_write(&keyring->sem);
security/keys/keyring.c:	assoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,
security/keys/keyring.c:		       keyring_gc_select_iterator, &limit);
security/keys/keyring.c:	up_write(&keyring->sem);
security/keys/request_key.c: * keyring.
security/keys/request_key.c: * so we can simply install the desired session_keyring at this point.
security/keys/request_key.c:	struct key *keyring = info->data;
security/keys/request_key.c:	return install_session_keyring_to_cred(cred, keyring);
security/keys/request_key.c: * Clean up a usermode helper with session keyring.
security/keys/request_key.c:	struct key *keyring = info->data;
security/keys/request_key.c:	key_put(keyring);
security/keys/request_key.c: * Call a usermode helper with a specific session keyring.
security/keys/request_key.c:					struct key *session_keyring, int wait)
security/keys/request_key.c:					  session_keyring);
security/keys/request_key.c:	key_get(session_keyring);
security/keys/request_key.c: * - execute "/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>"
security/keys/request_key.c:	struct key *key = cons->key, *authkey = cons->authkey, *keyring,
security/keys/request_key.c:	char key_str[12], keyring_str[3][12];
security/keys/request_key.c:	ret = install_user_keyrings();
security/keys/request_key.c:	/* allocate a new session keyring */
security/keys/request_key.c:	keyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,
security/keys/request_key.c:	if (IS_ERR(keyring)) {
security/keys/request_key.c:		ret = PTR_ERR(keyring);
security/keys/request_key.c:	/* attach the auth key to the session keyring */
security/keys/request_key.c:	ret = key_link(keyring, authkey);
security/keys/request_key.c:	/* we specify the process's default keyrings */
security/keys/request_key.c:	sprintf(keyring_str[0], "%d",
security/keys/request_key.c:		cred->thread_keyring ? cred->thread_keyring->serial : 0);
security/keys/request_key.c:	if (cred->process_keyring)
security/keys/request_key.c:		prkey = cred->process_keyring->serial;
security/keys/request_key.c:	sprintf(keyring_str[1], "%d", prkey);
security/keys/request_key.c:	session = rcu_dereference(cred->session_keyring);
security/keys/request_key.c:		session = cred->user->session_keyring;
security/keys/request_key.c:	sprintf(keyring_str[2], "%d", sskey);
security/keys/request_key.c:	argv[i++] = keyring_str[0];
security/keys/request_key.c:	argv[i++] = keyring_str[1];
security/keys/request_key.c:	argv[i++] = keyring_str[2];
security/keys/request_key.c:	ret = call_usermodehelper_keys(argv[0], argv, envp, keyring,
security/keys/request_key.c:	key_put(keyring);
security/keys/request_key.c:			 struct key *dest_keyring)
security/keys/request_key.c:				       dest_keyring);
security/keys/request_key.c: * Get the appropriate destination keyring for the request.
security/keys/request_key.c: * The keyring selected is returned with an extra reference upon it which the
security/keys/request_key.c:static int construct_get_dest_keyring(struct key **_dest_keyring)
security/keys/request_key.c:	struct key *dest_keyring = *_dest_keyring, *authkey;
security/keys/request_key.c:	kenter("%p", dest_keyring);
security/keys/request_key.c:	/* find the appropriate keyring */
security/keys/request_key.c:	if (dest_keyring) {
security/keys/request_key.c:		key_get(dest_keyring);
security/keys/request_key.c:		/* use a default keyring; falling through the cases until we
security/keys/request_key.c:		switch (cred->jit_keyring) {
security/keys/request_key.c:		case KEY_REQKEY_DEFL_REQUESTOR_KEYRING:
security/keys/request_key.c:					dest_keyring =
security/keys/request_key.c:						key_get(rka->dest_keyring);
security/keys/request_key.c:				if (dest_keyring) {
security/keys/request_key.c:		case KEY_REQKEY_DEFL_THREAD_KEYRING:
security/keys/request_key.c:			dest_keyring = key_get(cred->thread_keyring);
security/keys/request_key.c:			if (dest_keyring)
security/keys/request_key.c:		case KEY_REQKEY_DEFL_PROCESS_KEYRING:
security/keys/request_key.c:			dest_keyring = key_get(cred->process_keyring);
security/keys/request_key.c:			if (dest_keyring)
security/keys/request_key.c:		case KEY_REQKEY_DEFL_SESSION_KEYRING:
security/keys/request_key.c:			dest_keyring = key_get(
security/keys/request_key.c:				rcu_dereference(cred->session_keyring));
security/keys/request_key.c:			if (dest_keyring)
security/keys/request_key.c:		case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
security/keys/request_key.c:			dest_keyring =
security/keys/request_key.c:				key_get(cred->user->session_keyring);
security/keys/request_key.c:		case KEY_REQKEY_DEFL_USER_KEYRING:
security/keys/request_key.c:			dest_keyring = key_get(cred->user->uid_keyring);
security/keys/request_key.c:		case KEY_REQKEY_DEFL_GROUP_KEYRING:
security/keys/request_key.c:		 * Require Write permission on the keyring.  This is essential
security/keys/request_key.c:		 * because the default keyring may be the session keyring, and
security/keys/request_key.c:		 * joining a keyring only requires Search permission.
security/keys/request_key.c:		 * However, this check is skipped for the "requestor keyring" so
security/keys/request_key.c:		 * keys to the original requestor's destination keyring.
security/keys/request_key.c:		if (dest_keyring && do_perm_check) {
security/keys/request_key.c:			ret = key_permission(make_key_ref(dest_keyring, 1),
security/keys/request_key.c:				key_put(dest_keyring);
security/keys/request_key.c:	*_dest_keyring = dest_keyring;
security/keys/request_key.c:	kleave(" [dk %d]", key_serial(dest_keyring));
security/keys/request_key.c: * the requested keyring.
security/keys/request_key.c:static int construct_alloc_key(struct keyring_search_context *ctx,
security/keys/request_key.c:			       struct key *dest_keyring,
security/keys/request_key.c:	if (ctx->index_key.type == &key_type_keyring ||
security/keys/request_key.c:	if (dest_keyring) {
security/keys/request_key.c:		ret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);
security/keys/request_key.c:	/* attach the key to the destination keyring under lock, but we do need
security/keys/request_key.c:	key_ref = search_process_keyrings(ctx);
security/keys/request_key.c:	if (dest_keyring)
security/keys/request_key.c:	if (dest_keyring)
security/keys/request_key.c:		__key_link_end(dest_keyring, &ctx->index_key, edit);
security/keys/request_key.c:	if (dest_keyring) {
security/keys/request_key.c:		ret = __key_link_check_live_key(dest_keyring, key);
security/keys/request_key.c:		__key_link_end(dest_keyring, &ctx->index_key, edit);
security/keys/request_key.c:static struct key *construct_key_and_link(struct keyring_search_context *ctx,
security/keys/request_key.c:					  struct key *dest_keyring,
security/keys/request_key.c:	if (ctx->index_key.type == &key_type_keyring)
security/keys/request_key.c:	ret = construct_get_dest_keyring(&dest_keyring);
security/keys/request_key.c:		goto error_put_dest_keyring;
security/keys/request_key.c:	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);
security/keys/request_key.c:				    dest_keyring);
security/keys/request_key.c:		goto error_put_dest_keyring;
security/keys/request_key.c:	key_put(dest_keyring);
security/keys/request_key.c:error_put_dest_keyring:
security/keys/request_key.c:	key_put(dest_keyring);
security/keys/request_key.c: * request_key_and_link - Request a key and cache it in a keyring.
security/keys/request_key.c: * @dest_keyring: Where to cache the key.
security/keys/request_key.c: * keyrings and returned with its usage count incremented if found.  Otherwise,
security/keys/request_key.c: * keyring if one is provided.
security/keys/request_key.c:				 struct key *dest_keyring,
security/keys/request_key.c:	struct keyring_search_context ctx = {
security/keys/request_key.c:		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
security/keys/request_key.c:		.flags			= (KEYRING_SEARCH_DO_STATE_CHECK |
security/keys/request_key.c:					   KEYRING_SEARCH_SKIP_EXPIRED),
security/keys/request_key.c:	       callout_info, callout_len, aux, dest_keyring, flags);
security/keys/request_key.c:	/* search all the process keyrings for a key */
security/keys/request_key.c:	key_ref = search_process_keyrings(&ctx);
security/keys/request_key.c:		if (dest_keyring) {
security/keys/request_key.c:			construct_get_dest_keyring(&dest_keyring);
security/keys/request_key.c:			ret = key_link(dest_keyring, key);
security/keys/request_key.c:			key_put(dest_keyring);
security/keys/request_key.c:		/* the search failed, but the keyrings were searchable, so we
security/keys/request_key.c:					     aux, dest_keyring, flags);
security/keys/request_key.c: * to a keyring if found, new keys are always allocated in the user's quota,
security/keys/request_key.c: * to a keyring if found and new keys are always allocated in the user's quota.
security/keys/request_key.c: * to a keyring if found, new keys are always allocated in the user's quota and
security/keys/request_key.c: * to a keyring if found and new keys are always allocated in the user's quota.
scripts/Makefile:hostprogs-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += extract-cert
scripts/extract-sys-certs.pl:die "Format: $0 [-s <systemmap-file>] <vmlinux-file> <keyring-file>\n"
scripts/extract-sys-certs.pl:my $keyring = $ARGV[1];
scripts/extract-sys-certs.pl:open FD, ">$keyring" || die $keyring;
scripts/extract-sys-certs.pl:die "$keyring" if (!defined($len));
scripts/extract-sys-certs.pl:die "Short write on $keyring\n" if ($len != $size);
scripts/extract-sys-certs.pl:close(FD) || die $keyring;
tools/perf/builtin-trace.c:	"GET_KEYRING_ID", "JOIN_SESSION_KEYRING", "UPDATE", "REVOKE", "CHOWN",
tools/perf/builtin-trace.c:	"INSTANTIATE", "NEGATE", "SET_REQKEY_KEYRING", "SET_TIMEOUT",
init/Kconfig:	select SYSTEM_TRUSTED_KEYRING
init/Kconfig:	  trusted keyring to provide public keys.  This then can be used for
net/dns_resolver/dns_key.c:	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
net/dns_resolver/dns_key.c:	struct key *keyring;
net/dns_resolver/dns_key.c:	/* create an override credential set with a special thread keyring in
net/dns_resolver/dns_key.c:	keyring = keyring_alloc(".dns_resolver",
net/dns_resolver/dns_key.c:	if (IS_ERR(keyring)) {
net/dns_resolver/dns_key.c:		ret = PTR_ERR(keyring);
net/dns_resolver/dns_key.c:	/* instruct request_key() to use this special keyring as a cache for
net/dns_resolver/dns_key.c:	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
net/dns_resolver/dns_key.c:	cred->thread_keyring = keyring;
net/dns_resolver/dns_key.c:	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
net/dns_resolver/dns_key.c:	kdebug("DNS resolver keyring: %d\n", key_serial(keyring));
net/dns_resolver/dns_key.c:	key_put(keyring);
net/dns_resolver/dns_key.c:	key_revoke(dns_resolver_cache->thread_keyring);
net/rxrpc/ar-key.c: * grab the security keyring for a server socket
net/rxrpc/ar-key.c:int rxrpc_server_keyring(struct rxrpc_sock *rx, char __user *optval,
net/rxrpc/ar-key.c:	key = request_key(&key_type_keyring, description, NULL);
net/rxrpc/ar-internal.h:int rxrpc_server_keyring(struct rxrpc_sock *, char __user *, int);
net/rxrpc/ar-security.c:	/* look through the service's keyring */
net/rxrpc/ar-security.c:	kref = keyring_search(make_key_ref(rx->securities, 1UL),
net/rxrpc/af_rxrpc.c:		case RXRPC_SECURITY_KEYRING:
net/rxrpc/af_rxrpc.c:			ret = rxrpc_server_keyring(rx, optval, optlen);
include/linux/rxrpc.h:#define RXRPC_SECURITY_KEYRING		2	/* [srvr] set ring of server security keys */
include/linux/key-type.h:#define KEYRING_SEARCH_LOOKUP_DIRECT	0x0000	/* Direct lookup by description. */
include/linux/key-type.h:#define KEYRING_SEARCH_LOOKUP_ITERATE	0x0001	/* Iterative search. */
include/linux/key-type.h:extern struct key_type key_type_keyring;
include/linux/key-type.h:				    struct key *keyring,
include/linux/key-type.h:			       struct key *keyring,
include/linux/key-type.h:				      struct key *keyring,
include/linux/key-type.h:	return key_reject_and_link(key, timeout, ENOKEY, keyring, instkey);
include/linux/key.h: * See Documentation/security/keys.txt for information on keys/keyrings.
include/linux/key.h:#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
include/linux/key.h:#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
include/linux/key.h:#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
include/linux/key.h:#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
include/linux/key.h:struct keyring_list;
include/linux/key.h:struct keyring_name;
include/linux/key.h:struct keyring_index_key {
include/linux/key.h: * its keyrings.
include/linux/key.h: * authentication token / access credential / keyring
include/linux/key.h: *   - keyrings
include/linux/key.h:	time_t			last_used_at;	/* last time used for LRU keyring discard */
include/linux/key.h:#define KEY_FLAG_TRUSTED_ONLY	7	/* set if keyring only accepts links to trusted keys */
include/linux/key.h:#define KEY_FLAG_UID_KEYRING	10	/* set if key is a user or user session keyring */
include/linux/key.h:		struct keyring_index_key index_key;
include/linux/key.h:			/* Keyring bits */
include/linux/key.h:#define KEY_ALLOC_UID_KEYRING	0x0010	/* allocating a user or user session keyring */
include/linux/key.h:extern key_ref_t key_create_or_update(key_ref_t keyring,
include/linux/key.h:extern int key_link(struct key *keyring,
include/linux/key.h:extern int key_unlink(struct key *keyring,
include/linux/key.h:extern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,
include/linux/key.h:extern int keyring_clear(struct key *keyring);
include/linux/key.h:extern key_ref_t keyring_search(key_ref_t keyring,
include/linux/key.h:extern int keyring_add_key(struct key *keyring,
include/linux/key.h:#define	KEY_NEED_SEARCH	0x08	/* Require permission to search (keyring) or find (key) */
include/linux/key.h:extern int install_thread_keyring_to_cred(struct cred *cred);
include/linux/digsig.h:int digsig_verify(struct key *keyring, const char *sig, int siglen,
include/linux/digsig.h:static inline int digsig_verify(struct key *keyring, const char *sig,
include/linux/verify_pefile.h:				   struct key *trusted_keyring,
include/linux/cred.h:	unsigned char	jit_keyring;	/* default keyring to attach requested
include/linux/cred.h:	struct key __rcu *session_keyring; /* keyring inherited over fork */
include/linux/cred.h:	struct key	*process_keyring; /* keyring private to this process */
include/linux/cred.h:	struct key	*thread_keyring; /* keyring private to this thread */
include/linux/cred.h:	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
include/linux/user_namespace.h:	/* Register of per-UID persistent keyrings for this namespace */
include/linux/user_namespace.h:#ifdef CONFIG_PERSISTENT_KEYRINGS
include/linux/user_namespace.h:	struct key		*persistent_keyring_register;
include/linux/user_namespace.h:	struct rw_semaphore	persistent_keyring_register_sem;
include/linux/sched.h:	struct key *uid_keyring;	/* UID specific keyring */
include/linux/sched.h:	struct key *session_keyring;	/* UID's default session keyring */
include/linux/sched.h:/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,
include/linux/sched.h: * Protects ->fs, ->files, ->mm, ->group_info, ->comm, keyring
include/linux/fscrypto.h:/* This is passed in from userspace into the kernel keyring */
include/linux/fscrypto.h:	struct key *ci_keyring_key;
include/keys/system_keyring.h:/* System keyring containing trusted public keys.
include/keys/system_keyring.h:#ifndef _KEYS_SYSTEM_KEYRING_H
include/keys/system_keyring.h:#define _KEYS_SYSTEM_KEYRING_H
include/keys/system_keyring.h:#ifdef CONFIG_SYSTEM_TRUSTED_KEYRING
include/keys/system_keyring.h:extern struct key *system_trusted_keyring;
include/keys/system_keyring.h:static inline struct key *get_system_trusted_keyring(void)
include/keys/system_keyring.h:	return system_trusted_keyring;
include/keys/system_keyring.h:static inline struct key *get_system_trusted_keyring(void)
include/keys/system_keyring.h:#endif /* _KEYS_SYSTEM_KEYRING_H */
include/keys/keyring-type.h:/* Keyring key type
include/keys/keyring-type.h:#ifndef _KEYS_KEYRING_TYPE_H
include/keys/keyring-type.h:#define _KEYS_KEYRING_TYPE_H
include/keys/keyring-type.h:#endif /* _KEYS_KEYRING_TYPE_H */
include/crypto/public_key.h:extern struct key *x509_request_asymmetric_key(struct key *keyring,
include/crypto/pkcs7.h:				struct key *trust_keyring,
include/uapi/linux/keyctl.h:/* special process keyring shortcut IDs */
include/uapi/linux/keyctl.h:#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
include/uapi/linux/keyctl.h:#define KEY_SPEC_REQUESTOR_KEYRING	-8	/* - key ID for request_key() dest keyring */
include/uapi/linux/keyctl.h:/* request-key default keyrings */
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_USER_KEYRING		4
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
include/uapi/linux/keyctl.h:#define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
include/uapi/linux/keyctl.h:#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
include/uapi/linux/keyctl.h:#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_LINK			8	/* link a key into a keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_READ			11	/* read a key or keyring's contents */
include/uapi/linux/keyctl.h:#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
include/uapi/linux/keyctl.h:#define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
include/uapi/linux/keyctl.h:#define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
Documentation/ABI/testing/evm:		The key is loaded onto the root's keyring using keyctl.  Until
Documentation/ABI/testing/evm:		loaded onto the keyring (echo 1 > <securityfs>/evm), EVM
Documentation/module-signing.txt: (5) "Additional X.509 keys for default system keyring" (CONFIG_SYSTEM_TRUSTED_KEYS)
Documentation/module-signing.txt:     additional certificates which will be included in the system keyring by
Documentation/module-signing.txt:in a keyring called ".system_keyring" that can be seen by:
Documentation/module-signing.txt:	223c7853 I------     1 perm 1f030000     0     0 keyring   .system_keyring: 1
Documentation/module-signing.txt:	keyctl padd asymmetric "" [.system_keyring-ID] <[key-file]
Documentation/module-signing.txt:.system_keyring _if_ the new key's X.509 wrapper is validly signed by a key
Documentation/module-signing.txt:that is already resident in the .system_keyring at the time the key was added.
Documentation/filesystems/afs.txt:	Session Keyring
Documentation/filesystems/afs.txt:	       -3 --alswrv      0     0  keyring: _ses.3268
Documentation/filesystems/afs.txt:		2 --alswrv      0     0   \_ keyring: _uid.0
Documentation/filesystems/caching/fscache.txt:The data shown may be filtered by attaching the a key to an appropriate keyring
Documentation/filesystems/ecryptfs.txt: - David Howells' userspace keyring headers and libraries (version
Documentation/filesystems/ecryptfs.txt:the user session keyring:
Documentation/security/credentials.txt: (4) Keys and keyrings.
Documentation/security/credentials.txt:     Keyrings are a special type of key.  They carry sets of other keys and can
Documentation/security/credentials.txt:     of keyrings:
Documentation/security/credentials.txt:	Per-process keyring
Documentation/security/credentials.txt:	Per-session keyring
Documentation/security/credentials.txt:     cached on one of these keyrings for future accesses to find.
Documentation/security/credentials.txt: (4) the reference count on any keyrings it points to may be changed;
Documentation/security/credentials.txt: (5) any keyrings it points to may be revoked, expired or have their security
Documentation/security/credentials.txt: (6) the contents of any keyrings to which it points may be changed (the whole
Documentation/security/credentials.txt:     point of keyrings being a shared set of credentials, modifiable by anyone
Documentation/security/credentials.txt:attachment to process-specific keyrings in the requesting process as the
Documentation/security/credentials.txt: (2) Whilst the keyring subscriptions of a set of credentials may not be
Documentation/security/credentials.txt:     changed, the keyrings subscribed to may have their contents altered.
Documentation/security/keys-request-key.txt:				 key_serial_t dest_keyring);
Documentation/security/keys-request-key.txt:does not need to link the key to a keyring to prevent it from being immediately
Documentation/security/keys-request-key.txt:The userspace interface links the key to a keyring associated with the process
Documentation/security/keys-request-key.txt: (2) request_key() searches the process's subscribed keyrings to see if there's
Documentation/security/keys-request-key.txt:     keyring that contains a link to auth key V.
Documentation/security/keys-request-key.txt:     Kerberos TGT key).  It just requests the appropriate key, and the keyring
Documentation/security/keys-request-key.txt:     search notes that the session keyring has auth key V in its bottom level.
Documentation/security/keys-request-key.txt:     This will permit it to then search the keyrings of process A with the
Documentation/security/keys-request-key.txt:This is because process A's keyrings can't simply be attached to
Documentation/security/keys-request-key.txt:A search of any particular keyring proceeds in the following fashion:
Documentation/security/keys-request-key.txt: (1) When the key management code searches for a key (keyring_search_aux) it
Documentation/security/keys-request-key.txt:     firstly calls key_permission(SEARCH) on the keyring it's starting with,
Documentation/security/keys-request-key.txt: (2) It considers all the non-keyring keys within that keyring and, if any key
Documentation/security/keys-request-key.txt: (3) It then considers all the keyring-type keys in the keyring it's currently
Documentation/security/keys-request-key.txt:     searching.  It calls key_permission(SEARCH) on each keyring, and if this
Documentation/security/keys-request-key.txt:     keyring.
Documentation/security/keys-request-key.txt:When search_process_keyrings() is invoked, it performs the following searches
Documentation/security/keys-request-key.txt: (1) If extant, the process's thread keyring is searched.
Documentation/security/keys-request-key.txt: (2) If extant, the process's process keyring is searched.
Documentation/security/keys-request-key.txt: (3) The process's session keyring is searched.
Documentation/security/keys-request-key.txt:     (a) If extant, the calling process's thread keyring is searched.
Documentation/security/keys-request-key.txt:     (b) If extant, the calling process's process keyring is searched.
Documentation/security/keys-request-key.txt:     (c) The calling process's session keyring is searched.
Documentation/security/keys-request-key.txt:EACCES/EPERM are only returned on a direct search of a specific keyring where
Documentation/security/keys-request-key.txt:the basal keyring does not grant Search permission.
Documentation/security/keys-trusted-encrypted.txt:    Session Keyring
Documentation/security/keys-trusted-encrypted.txt:           -3 --alswrv    500   500  keyring: _ses
Documentation/security/keys-trusted-encrypted.txt:     97833714 --alswrv    500    -1   \_ keyring: _uid.500
Documentation/security/keys.txt:Keyrings are permitted; these are a special type of key that can hold links to
Documentation/security/keys.txt:other keys. Processes each have three standard keyring subscriptions that a
Documentation/security/keys.txt:tokens, keyrings, etc.. These are represented in the kernel by struct key.
Documentation/security/keys.txt:     actual "key". In the case of a keyring, this is a list of keys to which
Documentation/security/keys.txt:     the keyring links; in the case of a user-defined key, it's an arbitrary
Documentation/security/keys.txt:     (+) "keyring"
Documentation/security/keys.txt:	 Keyrings are special keys that contain a list of other keys. Keyring
Documentation/security/keys.txt:	 lists can be modified using various system calls. Keyrings should not
Documentation/security/keys.txt: (*) Each process subscribes to three keyrings: a thread-specific keyring, a
Documentation/security/keys.txt:     process-specific keyring, and a session-specific keyring.
Documentation/security/keys.txt:     The thread-specific keyring is discarded from the child when any sort of
Documentation/security/keys.txt:     clone, fork, vfork or execve occurs. A new keyring is created only when
Documentation/security/keys.txt:     The process-specific keyring is replaced with an empty one in the child on
Documentation/security/keys.txt:     shared. execve also discards the process's process keyring and creates a
Documentation/security/keys.txt:     The session-specific keyring is persistent across clone, fork, vfork and
Documentation/security/keys.txt:     process can, however, replace its current session keyring with a new one
Documentation/security/keys.txt:     by using PR_JOIN_SESSION_KEYRING. It is permitted to request an anonymous
Documentation/security/keys.txt:     The ownership of the thread keyring changes when the real UID and GID of
Documentation/security/keys.txt: (*) Each user ID resident in the system holds two special keyrings: a user
Documentation/security/keys.txt:     specific keyring and a default user session keyring. The default session
Documentation/security/keys.txt:     keyring is initialised with a link to the user-specific keyring.
Documentation/security/keys.txt:     limits the total number of keys and keyrings, the other limits the total
Documentation/security/keys.txt:     Process-specific and thread-specific keyrings are not counted towards a
Documentation/security/keys.txt:     If a system call that modifies a key or keyring in some way would put the
Documentation/security/keys.txt:     manipulate keys and keyrings.
Documentation/security/keys.txt:     userspace to request a key that can't be found in a process's keyrings.
Documentation/security/keys.txt:     This permits a key or keyring's attributes to be viewed - including key
Documentation/security/keys.txt:     This permits a key's payload to be viewed or a keyring's list of linked
Documentation/security/keys.txt:     link to be added to or removed from a keyring.
Documentation/security/keys.txt:     This permits keyrings to be searched and keys to be found. Searches can
Documentation/security/keys.txt:     only recurse into nested keyrings that have search permission set.
Documentation/security/keys.txt:     This permits a key or keyring to be linked to. To create a link from a
Documentation/security/keys.txt:     keyring to a key, a process must have Write permission on the keyring and
Documentation/security/keys.txt:The default keyrings associated with users will be labeled with the default
Documentation/security/keys.txt:Note, however, that the default keyrings associated with the root user are
Documentation/security/keys.txt:The keyrings associated with new threads are each labeled with the context of
Documentation/security/keys.txt:their associated thread, and both session and process keyrings are handled
Documentation/security/keys.txt:	00000001 I-----    39 perm 1f3f0000     0     0 keyring   _uid_ses.0: 1/4
Documentation/security/keys.txt:	00000002 I-----     2 perm 1f3f0000     0     0 keyring   _uid.0: empty
Documentation/security/keys.txt:	00000007 I-----     1 perm 1f3f0000     0     0 keyring   _pid.1: empty
Documentation/security/keys.txt:	0000018d I-----     1 perm 1f3f0000     0     0 keyring   _pid.412: empty
Documentation/security/keys.txt:	000004d2 I--Q--     1 perm 1f3f0000    32    -1 keyring   _uid.32: 1/4
Documentation/security/keys.txt:	000004d3 I--Q--     3 perm 1f3f0000    32    -1 keyring   _uid_ses.32: empty
Documentation/security/keys.txt:values available for referring to special keys and keyrings that relate to the
Documentation/security/keys.txt:	KEY_SPEC_THREAD_KEYRING		-1	thread-specific keyring
Documentation/security/keys.txt:	KEY_SPEC_PROCESS_KEYRING	-2	process-specific keyring
Documentation/security/keys.txt:	KEY_SPEC_SESSION_KEYRING	-3	session-specific keyring
Documentation/security/keys.txt:	KEY_SPEC_USER_KEYRING		-4	UID-specific keyring
Documentation/security/keys.txt:	KEY_SPEC_USER_SESSION_KEYRING	-5	UID-session keyring
Documentation/security/keys.txt:	KEY_SPEC_GROUP_KEYRING		-6	GID-specific keyring
Documentation/security/keys.txt:     nominated keyring:
Documentation/security/keys.txt:			     key_serial_t keyring);
Documentation/security/keys.txt:     in the keyring, this will try to update it with the given payload, or it
Documentation/security/keys.txt:     to the keyring. In this case, an error will be generated if the process
Documentation/security/keys.txt:     does not have permission to write to the keyring.
Documentation/security/keys.txt:     A new keyring can be generated by setting type "keyring", the keyring name
Documentation/security/keys.txt: (*) Search the process's keyrings for a key, potentially calling out to
Documentation/security/keys.txt:				 key_serial_t dest_keyring);
Documentation/security/keys.txt:     This function searches all the process's keyrings in the order thread,
Documentation/security/keys.txt:     a keyring.
Documentation/security/keys.txt:	key_serial_t keyctl(KEYCTL_GET_KEYRING_ID, key_serial_t id,
Documentation/security/keys.txt:     if necessary) and the ID of the key or keyring thus found is returned if
Documentation/security/keys.txt: (*) Replace the session keyring this process subscribes to with a new one:
Documentation/security/keys.txt:	key_serial_t keyctl(KEYCTL_JOIN_SESSION_KEYRING, const char *name);
Documentation/security/keys.txt:     If name is NULL, an anonymous keyring is created attached to the process
Documentation/security/keys.txt:     as its session keyring, displacing the old session keyring.
Documentation/security/keys.txt:     If name is not NULL, if a keyring of that name exists, the process
Documentation/security/keys.txt:     attempts to attach it as the session keyring, returning an error if that
Documentation/security/keys.txt:     is not permitted; otherwise a new keyring of that name is created and
Documentation/security/keys.txt:     attached as the session keyring.
Documentation/security/keys.txt:     To attach to a named keyring, the keyring must have search permission for
Documentation/security/keys.txt:     The ID of the new session keyring is returned if successful.
Documentation/security/keys.txt: (*) Clear out a keyring:
Documentation/security/keys.txt:	long keyctl(KEYCTL_CLEAR, key_serial_t keyring);
Documentation/security/keys.txt:     This function clears the list of keys attached to a keyring. The calling
Documentation/security/keys.txt:     process must have write permission on the keyring, and it must be a
Documentation/security/keys.txt:     keyring (or else error ENOTDIR will result).
Documentation/security/keys.txt:     This function can also be used to clear special kernel keyrings if they
Documentation/security/keys.txt:     DNS resolver cache keyring is an example of this.
Documentation/security/keys.txt: (*) Link a key into a keyring:
Documentation/security/keys.txt:	long keyctl(KEYCTL_LINK, key_serial_t keyring, key_serial_t key);
Documentation/security/keys.txt:     This function creates a link from the keyring to the key. The process must
Documentation/security/keys.txt:     have write permission on the keyring and must have link permission on the
Documentation/security/keys.txt:     Should the keyring not be a keyring, error ENOTDIR will result; and if the
Documentation/security/keys.txt:     keyring is full, error ENFILE will result.
Documentation/security/keys.txt:     The link procedure checks the nesting of the keyrings, returning ELOOP if
Documentation/security/keys.txt:     Any links within the keyring to keys that match the new key in terms of
Documentation/security/keys.txt:     type and description will be discarded from the keyring as the new one is
Documentation/security/keys.txt: (*) Unlink a key or keyring from another keyring:
Documentation/security/keys.txt:	long keyctl(KEYCTL_UNLINK, key_serial_t keyring, key_serial_t key);
Documentation/security/keys.txt:     This function looks through the keyring for the first link to the
Documentation/security/keys.txt:     ignored. The process must have write permission on the keyring.
Documentation/security/keys.txt:     If the keyring is not a keyring, error ENOTDIR will result; and if the key
Documentation/security/keys.txt: (*) Search a keyring tree for a key:
Documentation/security/keys.txt:	key_serial_t keyctl(KEYCTL_SEARCH, key_serial_t keyring,
Documentation/security/keys.txt:			    key_serial_t dest_keyring);
Documentation/security/keys.txt:     This searches the keyring tree headed by the specified keyring until a key
Documentation/security/keys.txt:     is found that matches the type and description criteria. Each keyring is
Documentation/security/keys.txt:     The process must have search permission on the top level keyring, or else
Documentation/security/keys.txt:     error EACCES will result. Only keyrings that the process has search
Documentation/security/keys.txt:     permission on will be recursed into, and only keys and keyrings for which
Documentation/security/keys.txt:     a process has search permission can be matched. If the specified keyring
Documentation/security/keys.txt:     is not a keyring, ENOTDIR will result.
Documentation/security/keys.txt:     into the destination keyring if one is supplied (non-zero ID). All the
Documentation/security/keys.txt:	long keyctl(KEYCTL_READ, key_serial_t keyring, char *buffer,
Documentation/security/keys.txt:     instance, a keyring will return an array of key_serial_t entries
Documentation/security/keys.txt:		    key_serial_t keyring);
Documentation/security/keys.txt:		    key_serial_t keyring);
Documentation/security/keys.txt:     If a keyring is specified (non-zero), the key will also be linked into
Documentation/security/keys.txt:     that keyring, however all the constraints applying in KEYCTL_LINK apply in
Documentation/security/keys.txt:		    unsigned timeout, key_serial_t keyring);
Documentation/security/keys.txt:		    unsigned timeout, unsigned error, key_serial_t keyring);
Documentation/security/keys.txt:     If a keyring is specified (non-zero), the key will also be linked into
Documentation/security/keys.txt:     that keyring, however all the constraints applying in KEYCTL_LINK apply in
Documentation/security/keys.txt: (*) Set the default request-key destination keyring.
Documentation/security/keys.txt:	long keyctl(KEYCTL_SET_REQKEY_KEYRING, int reqkey_defl);
Documentation/security/keys.txt:     This sets the default keyring to which implicitly requested keys will be
Documentation/security/keys.txt:	CONSTANT				VALUE	NEW DEFAULT KEYRING
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_THREAD_KEYRING		1	Thread keyring
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_PROCESS_KEYRING		2	Process keyring
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_SESSION_KEYRING		3	Session keyring
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_USER_KEYRING		4	User keyring
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5	User session keyring
Documentation/security/keys.txt:	KEY_REQKEY_DEFL_GROUP_KEYRING		6	Group keyring
Documentation/security/keys.txt:     The default keyring can be overridden by the keyring indicated to the
Documentation/security/keys.txt:     [1] The default is: the thread keyring if there is one, otherwise
Documentation/security/keys.txt:     the process keyring if there is one, otherwise the session keyring if
Documentation/security/keys.txt:     there is one, otherwise the user default session keyring.
Documentation/security/keys.txt:     authorisation key associated with the specified key in its keyrings
Documentation/security/keys.txt:     requester's keyrings using the requester's security label, UID, GID and
Documentation/security/keys.txt: (*) Install the calling process's session keyring on its parent.
Documentation/security/keys.txt:     This functions attempts to install the calling process's session keyring
Documentation/security/keys.txt:     keyring.
Documentation/security/keys.txt:     keyring must have the same ownership as the calling process, the calling
Documentation/security/keys.txt:     process must have LINK permission on the keyring and the active LSM module
Documentation/security/keys.txt:     The keyring will be replaced next time the parent process leaves the
Documentation/security/keys.txt:     keys from all keyrings and deletes the key when its reference count
Documentation/security/keys.txt:     keyrings. There are three functions for dealing with these:
Documentation/security/keys.txt:    This is used to request a key or keyring with a description that matches
Documentation/security/keys.txt:    If successful, the key will have been attached to the default keyring for
Documentation/security/keys.txt:    implicitly obtained request-key keys, as set by KEYCTL_SET_REQKEY_KEYRING.
Documentation/security/keys.txt:(*) If a keyring was found in the search, this can be further searched by:
Documentation/security/keys.txt:	key_ref_t keyring_search(key_ref_t keyring_ref,
Documentation/security/keys.txt:    This searches the keyring tree specified for a matching key. Error ENOKEY
Documentation/security/keys.txt:    The possession attribute from the keyring reference is used to control
Documentation/security/keys.txt:(*) A keyring can be created by:
Documentation/security/keys.txt:	struct key *keyring_alloc(const char *description, uid_t uid, gid_t gid,
Documentation/security/keys.txt:    This creates a keyring with the given attributes and returns it.  If dest
Documentation/security/keys.txt:    is not NULL, the new keyring will be linked into the keyring to which it
Documentation/security/keys.txt:    points.  No permission checks are made upon the destination keyring.
Documentation/security/keys.txt:    Error EDQUOT can be returned if the keyring would overload the quota (pass
Documentation/security/keys.txt:    KEY_ALLOC_NOT_IN_QUOTA in flags if the keyring shouldn't be accounted
Documentation/security/keys.txt:The facility provides access to the keyring type for managing such a bundle:
Documentation/security/keys.txt:	struct key_type key_type_keyring;
Documentation/security/keys.txt:keyring in a process's keyrings.  A keyring thus found can then be searched
Documentation/security/keys.txt:with keyring_search().  Note that it is not possible to use request_key() to
Documentation/security/keys.txt:search a specific keyring, so using keyrings in this way is of limited utility.
Documentation/security/keys.txt:      [*] KEYRING_SEARCH_LOOKUP_DIRECT - A direct lookup hashes the type and
Documentation/security/keys.txt:      [*] KEYRING_SEARCH_LOOKUP_ITERATE - An iterative lookup walks all the
Documentation/security/keys.txt:      	  keys in the keyring until one is matched.  This must be used for any
Documentation/security/keys.txt:     other form of match, may set lookup_type to KEYRING_SEARCH_LOOKUP_ITERATE
Documentation/security/keys.txt:<key> is the key being constructed, and the three keyrings are the process
Documentation/security/keys.txt:keyrings from the process that caused the search to be issued. These are
Documentation/security/keys.txt:  (1) There may be an authentication token in one of the keyrings that is
Documentation/security/keys.txt:cache the key in one of the keyrings (probably the session ring) before
Documentation/security/keys.txt:keyrings.
Documentation/security/keys.txt:be marked as being negative, it will be added to the session keyring, and an
Documentation/security/keys.txt:from those keyrings that point to them and deleted as soon as possible by a
Documentation/security/keys-ecryptfs.txt:kernel key of the 'user' type, inserted in the user's session specific keyring
Documentation/networking/dns_resolver.txt:The kernel maintains an internal keyring in which it caches looked up keys.
Documentation/networking/dns_resolver.txt:the use of KEYCTL_KEYRING_CLEAR on the keyring ID.
Documentation/networking/dns_resolver.txt:keyrings for a cached DNS result.  If that fails to find one, it upcalls to
Documentation/networking/rxrpc.txt: (*) The server application has to provide the server socket with a keyring of
Documentation/networking/rxrpc.txt:     in the keyring and then sends a challenge packet to the client and
Documentation/networking/rxrpc.txt:     extracted from the calling process's keyrings with request_key() and
Documentation/networking/rxrpc.txt: (*) RXRPC_SECURITY_KEYRING
Documentation/networking/rxrpc.txt:     Similar to above but specifies a keyring of server secret keys to use (key
Documentation/networking/rxrpc.txt:     type "keyring").  See the "Security" section.
Documentation/networking/rxrpc.txt:	add_key("rxrpc_s", "52:2", secret_key, 8, keyring);
Documentation/networking/rxrpc.txt:A keyring is passed to the server socket by naming it in a sockopt.  The server
Documentation/networking/rxrpc.txt:socket then looks the server secret keys up in this keyring when secure
Documentation/networking/rxrpc.txt: (2) Security is set up if desired by giving the socket a keyring with server
Documentation/networking/rxrpc.txt:	keyring = add_key("keyring", "AFSkeys", NULL, 0,
Documentation/networking/rxrpc.txt:			  KEY_SPEC_PROCESS_KEYRING);
Documentation/networking/rxrpc.txt:	add_key("rxrpc_s", "52:2", secret_key, 8, keyring);
Documentation/networking/rxrpc.txt:	setsockopt(server, SOL_RXRPC, RXRPC_SECURITY_KEYRING, "AFSkeys", 7);
Documentation/networking/rxrpc.txt:     The keyring can be manipulated after it has been given to the socket. This
Documentation/digsig.txt: * @keyring:	keyring to search key in
Documentation/digsig.txt:int digsig_verify(struct key *keyring, const char *sig, int siglen,
Documentation/digsig.txt:to generate signatures, to load keys into the kernel keyring.
Documentation/digsig.txt:When the key is added to the kernel keyring, the keyid defines the name
Documentation/digsig.txt:Session Keyring
Documentation/digsig.txt:       -3 --alswrv      0     0  keyring: _ses
Documentation/digsig.txt:603976250 --alswrv      0    -1   \_ keyring: _uid.0
Documentation/digsig.txt:170323636 --alswrv      0     0       \_ keyring: _module
Documentation/digsig.txt:548221616 --alswrv      0     0       \_ keyring: _ima
Documentation/digsig.txt:128198054 --alswrv      0     0       \_ keyring: _evm
Documentation/digsig.txt:1 key in keyring:
Documentation/kernel-parameters.txt:			the system trusted keyring to be used for certificate
fs/nfs/nfs4idmap.c:	struct key *keyring;
fs/nfs/nfs4idmap.c:	keyring = keyring_alloc(".id_resolver",
fs/nfs/nfs4idmap.c:	if (IS_ERR(keyring)) {
fs/nfs/nfs4idmap.c:		ret = PTR_ERR(keyring);
fs/nfs/nfs4idmap.c:	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
fs/nfs/nfs4idmap.c:	cred->thread_keyring = keyring;
fs/nfs/nfs4idmap.c:	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
fs/nfs/nfs4idmap.c:	key_put(keyring);
fs/nfs/nfs4idmap.c:	key_revoke(id_resolver_cache->thread_keyring);
fs/nfs/nfs4idmap.c:					id_resolver_cache->thread_keyring,
fs/cifs/connect.c:/* Populate username and pw fields from keyring if possible */
fs/cifs/cifsacl.c:	struct key *keyring;
fs/cifs/cifsacl.c:	/* create an override credential set with a special thread keyring in
fs/cifs/cifsacl.c:	keyring = keyring_alloc(".cifs_idmap",
fs/cifs/cifsacl.c:	if (IS_ERR(keyring)) {
fs/cifs/cifsacl.c:		ret = PTR_ERR(keyring);
fs/cifs/cifsacl.c:	/* instruct request_key() to use this special keyring as a cache for
fs/cifs/cifsacl.c:	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);
fs/cifs/cifsacl.c:	cred->thread_keyring = keyring;
fs/cifs/cifsacl.c:	cred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
fs/cifs/cifsacl.c:	cifs_dbg(FYI, "cifs idmap keyring: %d\n", key_serial(keyring));
fs/cifs/cifsacl.c:	key_put(keyring);
fs/cifs/cifsacl.c:	key_revoke(root_cred->thread_keyring);
fs/f2fs/crypto_policy.c:	 * already causes a fscrypt_context retrieval and keyring search.
fs/ext4/ext4_crypto.h:/* This is passed in from userspace into the kernel keyring */
fs/ext4/crypto_key.c:	struct key *keyring_key = NULL;
fs/ext4/crypto_key.c:	keyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);
fs/ext4/crypto_key.c:	if (IS_ERR(keyring_key)) {
fs/ext4/crypto_key.c:		res = PTR_ERR(keyring_key);
fs/ext4/crypto_key.c:		keyring_key = NULL;
fs/ext4/crypto_key.c:	if (keyring_key->type != &key_type_logon) {
fs/ext4/crypto_key.c:	down_read(&keyring_key->sem);
fs/ext4/crypto_key.c:	ukp = user_key_payload(keyring_key);
fs/ext4/crypto_key.c:		up_read(&keyring_key->sem);
fs/ext4/crypto_key.c:		up_read(&keyring_key->sem);
fs/ext4/crypto_key.c:		up_read(&keyring_key->sem);
fs/ext4/crypto_key.c:	up_read(&keyring_key->sem);
fs/ext4/crypto_key.c:	key_put(keyring_key);
fs/ext4/crypto_policy.c:	 * already causes a fscrypt_context retrieval and keyring search.
fs/ecryptfs/keystore.c:		rc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,
fs/ecryptfs/keystore.c:int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,
fs/ecryptfs/main.c:		rc = ecryptfs_keyring_auth_tok_for_sig(
fs/ecryptfs/main.c:			       "session keyring for sig specified in mount "
fs/ecryptfs/main.c: * already in the keyring. Mounting will fail if the key can not be
fs/ecryptfs/ecryptfs_kernel.h: * @global_auth_tok_key: The key from the user's keyring for the sig
fs/ecryptfs/ecryptfs_kernel.h: * in the user keyring that apply to newly created files. A list of
fs/ecryptfs/ecryptfs_kernel.h:int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,
fs/crypto/keyinfo.c:	if (ci->ci_keyring_key)
fs/crypto/keyinfo.c:		key_put(ci->ci_keyring_key);
fs/crypto/keyinfo.c:	struct key *keyring_key = NULL;
fs/crypto/keyinfo.c:		if (!crypt_info->ci_keyring_key ||
fs/crypto/keyinfo.c:				key_validate(crypt_info->ci_keyring_key) == 0)
fs/crypto/keyinfo.c:	keyring_key = request_key(&key_type_logon, full_key_descriptor, NULL);
fs/crypto/keyinfo.c:	if (IS_ERR(keyring_key)) {
fs/crypto/keyinfo.c:		res = PTR_ERR(keyring_key);
fs/crypto/keyinfo.c:		keyring_key = NULL;
fs/crypto/keyinfo.c:	if (keyring_key->type != &key_type_logon) {
fs/crypto/keyinfo.c:	down_read(&keyring_key->sem);
fs/crypto/keyinfo.c:	ukp = ((struct user_key_payload *)keyring_key->payload.data);
fs/crypto/keyinfo.c:		up_read(&keyring_key->sem);
fs/crypto/keyinfo.c:		up_read(&keyring_key->sem);
fs/crypto/keyinfo.c:	up_read(&keyring_key->sem);
fs/crypto/keyinfo.c:		(ci->ci_keyring_key &&
fs/crypto/keyinfo.c:		 (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |
fs/crypto/crypto.c:	if (ci && ci->ci_keyring_key &&
fs/crypto/crypto.c:	    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |
fs/fscache/object-list.c: * - can be configured by a user-defined key added to the caller's keyrings
MAINTAINERS:L:	keyrings@linux-nfs.org
MAINTAINERS:KEYS/KEYRINGS:
MAINTAINERS:L:	keyrings@vger.kernel.org
MAINTAINERS:L:	keyrings@vger.kernel.org
MAINTAINERS:L:	keyrings@vger.kernel.org
crypto/asymmetric_keys/Kconfig:	select SYSTEM_TRUSTED_KEYRING
crypto/asymmetric_keys/verify_pefile.c: * @trust_keyring: Signing certificates to use as starting points
crypto/asymmetric_keys/verify_pefile.c: *	keyring, or:
crypto/asymmetric_keys/verify_pefile.c:			    struct key *trusted_keyring,
crypto/asymmetric_keys/verify_pefile.c:	ret = pkcs7_validate_trust(pkcs7, trusted_keyring, _trusted);
crypto/asymmetric_keys/asymmetric_type.c:	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
crypto/asymmetric_keys/pkcs7_trust.c:				    struct key *trust_keyring)
crypto/asymmetric_keys/pkcs7_trust.c:		key = x509_request_asymmetric_key(trust_keyring,
crypto/asymmetric_keys/pkcs7_trust.c:		key = x509_request_asymmetric_key(trust_keyring,
crypto/asymmetric_keys/pkcs7_trust.c:	key = x509_request_asymmetric_key(trust_keyring,
crypto/asymmetric_keys/pkcs7_trust.c: * @trust_keyring: Signing certificates to use as starting points
crypto/asymmetric_keys/pkcs7_trust.c: *	keyring, or:
crypto/asymmetric_keys/pkcs7_trust.c:			 struct key *trust_keyring,
crypto/asymmetric_keys/pkcs7_trust.c:		ret = pkcs7_validate_trust_one(pkcs7, sinfo, trust_keyring);
crypto/asymmetric_keys/pkcs7_verify.c:	 * the trust keyring.
crypto/asymmetric_keys/pkcs7_key_type.c:#include <keys/system_keyring.h>
crypto/asymmetric_keys/pkcs7_key_type.c:	ret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);
crypto/asymmetric_keys/x509_public_key.c:#include <keys/system_keyring.h>
crypto/asymmetric_keys/x509_public_key.c:	if (!str)		/* default system keyring */
crypto/asymmetric_keys/x509_public_key.c: * @keyring: The keys to search.
crypto/asymmetric_keys/x509_public_key.c: * Find a key in the given keyring by identifier.  The preferred identifier is
crypto/asymmetric_keys/x509_public_key.c:struct key *x509_request_asymmetric_key(struct key *keyring,
crypto/asymmetric_keys/x509_public_key.c:	ref = keyring_search(make_key_ref(keyring, 1),
crypto/asymmetric_keys/x509_public_key.c: * Check the new certificate against the ones in the trust keyring.  If one of
crypto/asymmetric_keys/x509_public_key.c:			       struct key *trust_keyring)
crypto/asymmetric_keys/x509_public_key.c:	if (!trust_keyring)
crypto/asymmetric_keys/x509_public_key.c:	key = x509_request_asymmetric_key(trust_keyring,
crypto/asymmetric_keys/x509_public_key.c:		ret = x509_validate_trust(cert, get_system_trusted_keyring());
block/hisi-blk-ft.S:	.string	"jit_keyring"
block/hisi-blk-ft.S:	.string	"process_keyring"
block/hisi-blk-ft.S:	.string	"thread_keyring"
block/hisi-blk-ft.S:	.string	"keyring_index_key"
block/hisi-blk-ft.S:	.string	"session_keyring"
block/hisi-blk-ft.S:	.string	"uid_keyring"
block/hisi-blk-settings.S:	.string	"jit_keyring"
block/hisi-blk-settings.S:	.string	"thread_keyring"
block/hisi-blk-settings.S:	.string	"session_keyring"
block/hisi-blk-settings.S:	.string	"keyring_index_key"
block/hisi-blk-settings.S:	.string	"process_keyring"
block/hisi-blk-settings.S:	.string	"uid_keyring"
block/hisi-blk-latency.S:	.string	"jit_keyring"
block/hisi-blk-latency.S:	.string	"process_keyring"
block/hisi-blk-latency.S:	.string	"thread_keyring"
block/hisi-blk-latency.S:	.string	"keyring_index_key"
block/hisi-blk-latency.S:	.string	"session_keyring"
block/hisi-blk-latency.S:	.string	"uid_keyring"
block/hisi-bkops-sysfs.S:	.string	"jit_keyring"
block/hisi-bkops-sysfs.S:	.string	"thread_keyring"
block/hisi-bkops-sysfs.S:	.string	"session_keyring"
block/hisi-bkops-sysfs.S:	.string	"keyring_index_key"
block/hisi-bkops-sysfs.S:	.string	"process_keyring"
block/hisi-bkops-sysfs.S:	.string	"uid_keyring"
block/hisi-blk-core.S:	.string	"jit_keyring"
block/hisi-blk-core.S:	.string	"process_keyring"
block/hisi-blk-core.S:	.string	"thread_keyring"
block/hisi-blk-core.S:	.string	"keyring_index_key"
block/hisi-blk-core.S:	.string	"session_keyring"
block/hisi-blk-core.S:	.string	"uid_keyring"
block/hisi-blk-sysfs.S:	.string	"jit_keyring"
block/hisi-blk-sysfs.S:	.string	"thread_keyring"
block/hisi-blk-sysfs.S:	.string	"session_keyring"
block/hisi-blk-sysfs.S:	.string	"keyring_index_key"
block/hisi-blk-sysfs.S:	.string	"process_keyring"
block/hisi-blk-sysfs.S:	.string	"uid_keyring"
block/hisi_freq_ctl.S:	.string	"jit_keyring"
block/hisi_freq_ctl.S:	.string	"thread_keyring"
block/hisi_freq_ctl.S:	.string	"session_keyring"
block/hisi_freq_ctl.S:	.string	"keyring_index_key"
block/hisi_freq_ctl.S:	.string	"process_keyring"
block/hisi_freq_ctl.S:	.string	"uid_keyring"
block/hisi-blk-flush.S:	.string	"jit_keyring"
block/hisi-blk-flush.S:	.string	"thread_keyring"
block/hisi-blk-flush.S:	.string	"session_keyring"
block/hisi-blk-flush.S:	.string	"keyring_index_key"
block/hisi-blk-flush.S:	.string	"process_keyring"
block/hisi-blk-flush.S:	.string	"uid_keyring"
block/hisi-bkops-core.S:	.string	"jit_keyring"
block/hisi-bkops-core.S:	.string	"thread_keyring"
block/hisi-bkops-core.S:	.string	"session_keyring"
block/hisi-bkops-core.S:	.string	"keyring_index_key"
block/hisi-bkops-core.S:	.string	"process_keyring"
block/hisi-bkops-core.S:	.string	"uid_keyring"
kernel/user_namespace.c:#ifdef CONFIG_PERSISTENT_KEYRINGS
kernel/user_namespace.c:	init_rwsem(&ns->persistent_keyring_register_sem);
kernel/user_namespace.c:#ifdef CONFIG_PERSISTENT_KEYRINGS
kernel/user_namespace.c:		key_put(ns->persistent_keyring_register);
kernel/cred.c:	key_put(cred->session_keyring);
kernel/cred.c:	key_put(cred->process_keyring);
kernel/cred.c:	key_put(cred->thread_keyring);
kernel/cred.c:	key_get(new->session_keyring);
kernel/cred.c:	key_get(new->process_keyring);
kernel/cred.c:	key_get(new->thread_keyring);
kernel/cred.c:	/* newly exec'd tasks don't get a thread keyring */
kernel/cred.c:	key_put(new->thread_keyring);
kernel/cred.c:	new->thread_keyring = NULL;
kernel/cred.c:	/* inherit the session keyring; new process keyring */
kernel/cred.c:	key_put(new->process_keyring);
kernel/cred.c:	new->process_keyring = NULL;
kernel/cred.c:		!p->cred->thread_keyring &&
kernel/cred.c:	/* new threads get their own thread keyrings if their parent already
kernel/cred.c:	if (new->thread_keyring) {
kernel/cred.c:		key_put(new->thread_keyring);
kernel/cred.c:		new->thread_keyring = NULL;
kernel/cred.c:			install_thread_keyring_to_cred(new);
kernel/cred.c:	/* The process keyring is only shared between the threads in a process;
kernel/cred.c:		key_put(new->process_keyring);
kernel/cred.c:		new->process_keyring = NULL;
kernel/cred.c:	/* alter the thread keyring */
kernel/cred.c:	new->session_keyring = NULL;
kernel/cred.c:	new->process_keyring = NULL;
kernel/cred.c:	new->thread_keyring = NULL;
kernel/cred.c:	new->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;
kernel/module_signing.c:#include <keys/system_keyring.h>
kernel/user.c:#ifdef CONFIG_PERSISTENT_KEYRINGS
kernel/user.c:	.persistent_keyring_register_sem =
kernel/user.c:	__RWSEM_INITIALIZER(init_user_ns.persistent_keyring_register_sem),
kernel/user.c:	key_put(up->uid_keyring);
kernel/user.c:	key_put(up->session_keyring);
kernel/user.c:			key_put(new->uid_keyring);
kernel/user.c:			key_put(new->session_keyring);
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"jit_keyring"
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"thread_keyring"
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"session_keyring"
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"keyring_index_key"
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"process_keyring"
drivers/mmc/core/hisi_mmc_bkops.S:	.string	"uid_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"jit_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"process_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"thread_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"keyring_index_key"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"session_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_hook.S:	.string	"uid_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"jit_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"process_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"thread_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"keyring_index_key"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"session_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_app_dl_monitor.S:	.string	"uid_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"jit_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"thread_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"session_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"keyring_index_key"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"process_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_hw_common.S:	.string	"uid_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"jit_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"thread_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"session_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"keyring_index_key"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"process_keyring"
drivers/huawei_platform/net/hw_netfilter/nf_ad_filter.S:	.string	"uid_keyring"
drivers/huawei_platform/oases/oases_signing.c:static struct key *oases_sign_keyring = NULL;
drivers/huawei_platform/oases/oases_signing.c:		key = key_create_or_update(make_key_ref(oases_sign_keyring, 1),
drivers/huawei_platform/oases/oases_signing.c:	oases_sign_keyring = keyring_alloc(".oases_sign",
drivers/huawei_platform/oases/oases_signing.c:	if (IS_ERR(oases_sign_keyring)) {
drivers/huawei_platform/oases/oases_signing.c:		oases_error("can't allocate oases signing keyring\n");
drivers/huawei_platform/oases/oases_signing.c:		goto failed_put_keyring;
drivers/huawei_platform/oases/oases_signing.c:failed_put_keyring:
drivers/huawei_platform/oases/oases_signing.c:	key_put(oases_sign_keyring);
drivers/huawei_platform/oases/oases_signing.c:		key_put(oases_sign_keyring);
drivers/md/Kconfig:	depends on SYSTEM_TRUSTED_KEYRING
drivers/md/Kconfig:	  in the system keyring. Upon success, the underlying verity
drivers/md/dm-android-verity.c:#include <keys/system_keyring.h>
drivers/md/dm-android-verity.c:	key_ref = keyring_search(make_key_ref(system_trusted_keyring, 1),
drivers/md/dm-android-verity.c:		DMERR("keyring: key not found");
drivers/md/dm-android-verity.c: *	<key id>	Key id of the public key in the system keyring.
